<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>TOS API: include/kernel.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TOS API
   </div>
  </td>
  <td style="padding-left: 10em;">
    <div ><a href="http://tos.sfsu.edu" style="font-size: 150%;">TOS Web Site</a> </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">kernel.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Header file for the TOS kernel.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;stdarg.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structWINDOW.html">WINDOW</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the properties of a specific window.  <a href="structWINDOW.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__PCB.html">PCB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the information associated with a TOS process.  <a href="struct__PCB.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structIDT.html">IDT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the data fields associated with an x86 interrupt.  <a href="structIDT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__Timer__Message.html">Timer_Message</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the information of the message which is sent by a client process to the timer service.  <a href="struct__Timer__Message.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__COM__Message.html">COM_Message</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the contents of a COM message.  <a href="struct__COM__Message.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__Keyb__Message.html">Keyb_Message</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the contents of a message to the keyboard process.  <a href="struct__Keyb__Message.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a0e92bfcd9e51ca39bbebc3dfb9c16014"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a0e92bfcd9e51ca39bbebc3dfb9c16014">MAX_PROCS</a>&#160;&#160;&#160;20</td></tr>
<tr class="memdesc:a0e92bfcd9e51ca39bbebc3dfb9c16014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the maximum number of TOS processes that can be created.  <a href="#a0e92bfcd9e51ca39bbebc3dfb9c16014">More...</a><br /></td></tr>
<tr class="separator:a0e92bfcd9e51ca39bbebc3dfb9c16014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc7a460bafe08baeb6b29065dd4f7c9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#aecc7a460bafe08baeb6b29065dd4f7c9">MAX_READY_QUEUES</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:aecc7a460bafe08baeb6b29065dd4f7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the number of elements in the array which implements the <a class="el" href="kernel_8h.html#ab4e099987c910c0a74ddb26ffe7b1774" title="An array of pointers to PCBs for those processes that are ready to use CPU cycles. ">ready_queue</a>.  <a href="#aecc7a460bafe08baeb6b29065dd4f7c9">More...</a><br /></td></tr>
<tr class="separator:aecc7a460bafe08baeb6b29065dd4f7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74af0876332d1a6258cff9745a1bd53"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#aa74af0876332d1a6258cff9745a1bd53">STATE_READY</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:aa74af0876332d1a6258cff9745a1bd53"><td class="mdescLeft">&#160;</td><td class="mdescRight">This state is assigned to processes that are eligible to run and are ready to use CPU cycles.  <a href="#aa74af0876332d1a6258cff9745a1bd53">More...</a><br /></td></tr>
<tr class="separator:aa74af0876332d1a6258cff9745a1bd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e13ad68fa4d5752084a5ef0e0085a66"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a8e13ad68fa4d5752084a5ef0e0085a66">STATE_ZOMBIE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a8e13ad68fa4d5752084a5ef0e0085a66"><td class="mdescLeft">&#160;</td><td class="mdescRight">This state is assigned to processes that are permanently off the <a class="el" href="kernel_8h.html#ab4e099987c910c0a74ddb26ffe7b1774" title="An array of pointers to PCBs for those processes that are ready to use CPU cycles. ">ready_queue</a> and will never run again.  <a href="#a8e13ad68fa4d5752084a5ef0e0085a66">More...</a><br /></td></tr>
<tr class="separator:a8e13ad68fa4d5752084a5ef0e0085a66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a702a7f1c65e77a83166f4642ae6e7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#ac2a702a7f1c65e77a83166f4642ae6e7">STATE_SEND_BLOCKED</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ac2a702a7f1c65e77a83166f4642ae6e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This state is assigned to a process that has called <a class="el" href="kernel_8h.html#a70e779a204bd7960376d8f122d5afd5a" title="Sends a message to the PORT of a receiver process, and a reply to the message is expected. ">send()</a>, but the receiver process has not yet called <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a>.  <a href="#ac2a702a7f1c65e77a83166f4642ae6e7">More...</a><br /></td></tr>
<tr class="separator:ac2a702a7f1c65e77a83166f4642ae6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a600b8498ae32f931e812309e3ea0b715"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a600b8498ae32f931e812309e3ea0b715">STATE_REPLY_BLOCKED</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a600b8498ae32f931e812309e3ea0b715"><td class="mdescLeft">&#160;</td><td class="mdescRight">This state is assigned to a sending process in the situation where the process has called <a class="el" href="kernel_8h.html#a70e779a204bd7960376d8f122d5afd5a" title="Sends a message to the PORT of a receiver process, and a reply to the message is expected. ">send()</a> and the receiver process has called <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a> but not yet called <a class="el" href="kernel_8h.html#afae559b6ee61d6e596c651dde6028582" title="Replies to a message. ">reply()</a>.  <a href="#a600b8498ae32f931e812309e3ea0b715">More...</a><br /></td></tr>
<tr class="separator:a600b8498ae32f931e812309e3ea0b715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08fbd3b65bb3ea13b91882b70606e0e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#ac08fbd3b65bb3ea13b91882b70606e0e">STATE_RECEIVE_BLOCKED</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:ac08fbd3b65bb3ea13b91882b70606e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This state is assigned to a process that has called <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a>, but there are no messages pending from any other process.  <a href="#ac08fbd3b65bb3ea13b91882b70606e0e">More...</a><br /></td></tr>
<tr class="separator:ac08fbd3b65bb3ea13b91882b70606e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16679ae7e3517177c16893143870a20f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a16679ae7e3517177c16893143870a20f">STATE_MESSAGE_BLOCKED</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:a16679ae7e3517177c16893143870a20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This state is assigned to a process that has called <a class="el" href="kernel_8h.html#aacc4f7df1c840c0e6f109dfde5ff934f" title="Sends a message to the PORT of a receiver process, from which no reply is expected. ">message()</a>, and the receiver process has not yet called <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a>.  <a href="#a16679ae7e3517177c16893143870a20f">More...</a><br /></td></tr>
<tr class="separator:a16679ae7e3517177c16893143870a20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b88515a00640cd5475dc031dc4424b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a81b88515a00640cd5475dc031dc4424b">STATE_INTR_BLOCKED</a>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:a81b88515a00640cd5475dc031dc4424b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This state is assigned to a process that is waiting for an interrupt to occur.  <a href="#a81b88515a00640cd5475dc031dc4424b">More...</a><br /></td></tr>
<tr class="separator:a81b88515a00640cd5475dc031dc4424b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558a765eeee1053f8664ea223e85dd95"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a558a765eeee1053f8664ea223e85dd95">MAGIC_PCB</a>&#160;&#160;&#160;0x4321dcba</td></tr>
<tr class="memdesc:a558a765eeee1053f8664ea223e85dd95"><td class="mdescLeft">&#160;</td><td class="mdescRight">A value used to verify that a data structure being accessed is a <a class="el" href="struct__PCB.html">PCB</a>.  <a href="#a558a765eeee1053f8664ea223e85dd95">More...</a><br /></td></tr>
<tr class="separator:a558a765eeee1053f8664ea223e85dd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ad70cc6e2125af9340a4bc26a83764"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a40ad70cc6e2125af9340a4bc26a83764">MAX_PORTS</a>&#160;&#160;&#160;(<a class="el" href="kernel_8h.html#a0e92bfcd9e51ca39bbebc3dfb9c16014">MAX_PROCS</a> * 2)</td></tr>
<tr class="memdesc:a40ad70cc6e2125af9340a4bc26a83764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the maximum number of <a class="el" href="struct__PORT__DEF.html">PORT</a>s supported in TOS.  <a href="#a40ad70cc6e2125af9340a4bc26a83764">More...</a><br /></td></tr>
<tr class="separator:a40ad70cc6e2125af9340a4bc26a83764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a7162a4cf2bc5e6950e2bf63c1ca47d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a5a7162a4cf2bc5e6950e2bf63c1ca47d">MAGIC_PORT</a>&#160;&#160;&#160;0x1234abcd</td></tr>
<tr class="memdesc:a5a7162a4cf2bc5e6950e2bf63c1ca47d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A value used to verify that a data structure being accessed is a <a class="el" href="struct__PORT__DEF.html">PORT</a>.  <a href="#a5a7162a4cf2bc5e6950e2bf63c1ca47d">More...</a><br /></td></tr>
<tr class="separator:a5a7162a4cf2bc5e6950e2bf63c1ca47d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532d7d98780162a882090e6c0e1e36fe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a532d7d98780162a882090e6c0e1e36fe">DISABLE_INTR</a>(save)</td></tr>
<tr class="memdesc:a532d7d98780162a882090e6c0e1e36fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assembly instructions that disable the interrupt subsystem of TOS to avoid race conditions.  <a href="#a532d7d98780162a882090e6c0e1e36fe">More...</a><br /></td></tr>
<tr class="separator:a532d7d98780162a882090e6c0e1e36fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529e0c1767f0b71a5269eeb7b09528cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a529e0c1767f0b71a5269eeb7b09528cf">ENABLE_INTR</a>(save)</td></tr>
<tr class="memdesc:a529e0c1767f0b71a5269eeb7b09528cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assembly instructions that enable the interrupt subsystem of TOS.  <a href="#a529e0c1767f0b71a5269eeb7b09528cf">More...</a><br /></td></tr>
<tr class="separator:a529e0c1767f0b71a5269eeb7b09528cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55de91647484665fcafacafc46373f6c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a55de91647484665fcafacafc46373f6c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a55de91647484665fcafacafc46373f6c">CODE_SELECTOR</a>&#160;&#160;&#160;0x8</td></tr>
<tr class="memdesc:a55de91647484665fcafacafc46373f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of the segment selector corresponding to the CODE segment in TOS. <br /></td></tr>
<tr class="separator:a55de91647484665fcafacafc46373f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7244572d50af1202e0ae8b84a5a84a33"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7244572d50af1202e0ae8b84a5a84a33"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a7244572d50af1202e0ae8b84a5a84a33">DATA_SELECTOR</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="memdesc:a7244572d50af1202e0ae8b84a5a84a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">The value of the segment selector corresponding to the DATA segment in TOS. <br /></td></tr>
<tr class="separator:a7244572d50af1202e0ae8b84a5a84a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9affc80dd8947cc1dcb1ae52801923c8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a9affc80dd8947cc1dcb1ae52801923c8">MAX_INTERRUPTS</a>&#160;&#160;&#160;256</td></tr>
<tr class="memdesc:a9affc80dd8947cc1dcb1ae52801923c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of elements in the Interrupt Descriptor Table ("IDT").  <a href="#a9affc80dd8947cc1dcb1ae52801923c8">More...</a><br /></td></tr>
<tr class="separator:a9affc80dd8947cc1dcb1ae52801923c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77db186991bef443443f3a7414e4d84e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a77db186991bef443443f3a7414e4d84e">IDT_ENTRY_SIZE</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:a77db186991bef443443f3a7414e4d84e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of bytes of an entry in the Interrupt Descriptor Table ("IDT").  <a href="#a77db186991bef443443f3a7414e4d84e">More...</a><br /></td></tr>
<tr class="separator:a77db186991bef443443f3a7414e4d84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7095fb363d08f6646611f9a47806647b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a7095fb363d08f6646611f9a47806647b">TIMER_IRQ</a>&#160;&#160;&#160;0x60</td></tr>
<tr class="memdesc:a7095fb363d08f6646611f9a47806647b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number associated with a timer interrupt.  <a href="#a7095fb363d08f6646611f9a47806647b">More...</a><br /></td></tr>
<tr class="separator:a7095fb363d08f6646611f9a47806647b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3685c78b9bd6dd0fa3861807e24a4e1b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a3685c78b9bd6dd0fa3861807e24a4e1b">COM1_IRQ</a>&#160;&#160;&#160;0x64</td></tr>
<tr class="memdesc:a3685c78b9bd6dd0fa3861807e24a4e1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number associated with a COM1 interrupt.  <a href="#a3685c78b9bd6dd0fa3861807e24a4e1b">More...</a><br /></td></tr>
<tr class="separator:a3685c78b9bd6dd0fa3861807e24a4e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8982f081d8608e775b0739cde65373d5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a8982f081d8608e775b0739cde65373d5">COM1_PORT</a>&#160;&#160;&#160;0x3f8</td></tr>
<tr class="memdesc:a8982f081d8608e775b0739cde65373d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base address of the I/O ports associated with COM1.  <a href="#a8982f081d8608e775b0739cde65373d5">More...</a><br /></td></tr>
<tr class="separator:a8982f081d8608e775b0739cde65373d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02d84052a299a0c207a8ea4c1a5636d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#ab02d84052a299a0c207a8ea4c1a5636d">COM2_IRQ</a>&#160;&#160;&#160;0x63</td></tr>
<tr class="memdesc:ab02d84052a299a0c207a8ea4c1a5636d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number associated with a COM2 interrupt.  <a href="#ab02d84052a299a0c207a8ea4c1a5636d">More...</a><br /></td></tr>
<tr class="separator:ab02d84052a299a0c207a8ea4c1a5636d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88373c3e34a242356333ec08389eae54"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a88373c3e34a242356333ec08389eae54">COM2_PORT</a>&#160;&#160;&#160;0x2f8</td></tr>
<tr class="memdesc:a88373c3e34a242356333ec08389eae54"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base address of the I/O ports associated with COM2.  <a href="#a88373c3e34a242356333ec08389eae54">More...</a><br /></td></tr>
<tr class="separator:a88373c3e34a242356333ec08389eae54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1cd1e736761fd2efc00615782a271e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#ab1cd1e736761fd2efc00615782a271e6">KEYB_IRQ</a>&#160;&#160;&#160;0x61</td></tr>
<tr class="memdesc:ab1cd1e736761fd2efc00615782a271e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number associated with a keyboard interrupt.  <a href="#ab1cd1e736761fd2efc00615782a271e6">More...</a><br /></td></tr>
<tr class="separator:ab1cd1e736761fd2efc00615782a271e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a050c65e107f0c828f856a231f4b4e788"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a050c65e107f0c828f856a231f4b4e788">BOOL</a></td></tr>
<tr class="memdesc:a050c65e107f0c828f856a231f4b4e788"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for true/false values, as an integer.  <a href="#a050c65e107f0c828f856a231f4b4e788">More...</a><br /></td></tr>
<tr class="separator:a050c65e107f0c828f856a231f4b4e788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de4d864680acdb06c6f6fe11cc3d7d8"><td class="memItemLeft" align="right" valign="top">typedef unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a5de4d864680acdb06c6f6fe11cc3d7d8">MEM_ADDR</a></td></tr>
<tr class="memdesc:a5de4d864680acdb06c6f6fe11cc3d7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for memory addresses within the main memory used by TOS.  <a href="#a5de4d864680acdb06c6f6fe11cc3d7d8">More...</a><br /></td></tr>
<tr class="separator:a5de4d864680acdb06c6f6fe11cc3d7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae1dab0fb4b072a66584546209e7d58"><td class="memItemLeft" align="right" valign="top">typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a></td></tr>
<tr class="memdesc:a4ae1dab0fb4b072a66584546209e7d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a single-byte data type.  <a href="#a4ae1dab0fb4b072a66584546209e7d58">More...</a><br /></td></tr>
<tr class="separator:a4ae1dab0fb4b072a66584546209e7d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197942eefa7db30960ae396d68339b97"><td class="memItemLeft" align="right" valign="top">typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a197942eefa7db30960ae396d68339b97">WORD</a></td></tr>
<tr class="memdesc:a197942eefa7db30960ae396d68339b97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for an unsigned 2-byte data type.  <a href="#a197942eefa7db30960ae396d68339b97">More...</a><br /></td></tr>
<tr class="separator:a197942eefa7db30960ae396d68339b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434cb264031f389cbbf1844726748ebc"><td class="memItemLeft" align="right" valign="top">typedef unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a434cb264031f389cbbf1844726748ebc">LONG</a></td></tr>
<tr class="memdesc:a434cb264031f389cbbf1844726748ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for an unsigned 4-byte data type.  <a href="#a434cb264031f389cbbf1844726748ebc">More...</a><br /></td></tr>
<tr class="separator:a434cb264031f389cbbf1844726748ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a831d87f38811800ce0698bbe85e6b386"><td class="memItemLeft" align="right" valign="top">typedef PCB *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a831d87f38811800ce0698bbe85e6b386">PROCESS</a></td></tr>
<tr class="memdesc:a831d87f38811800ce0698bbe85e6b386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for a pointer to a <a class="el" href="struct__PCB.html">PCB</a> struct.  <a href="#a831d87f38811800ce0698bbe85e6b386">More...</a><br /></td></tr>
<tr class="separator:a831d87f38811800ce0698bbe85e6b386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f26503eb4a201692c1e8d8bb2e168d"><td class="memItemLeft" align="right" valign="top">typedef unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a83f26503eb4a201692c1e8d8bb2e168d">PARAM</a></td></tr>
<tr class="memdesc:a83f26503eb4a201692c1e8d8bb2e168d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A typedef that creates the alternative name PARAM for an unsigned integer type.  <a href="#a83f26503eb4a201692c1e8d8bb2e168d">More...</a><br /></td></tr>
<tr class="separator:a83f26503eb4a201692c1e8d8bb2e168d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7619b847aeded8a6d14cbfa212b2cdfb"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a7619b847aeded8a6d14cbfa212b2cdfb">size_t</a></td></tr>
<tr class="memdesc:a7619b847aeded8a6d14cbfa212b2cdfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef for an integer, representing the size in bytes of the memory region being requested from <a class="el" href="kernel_8h.html#a7ac38fce3243a7dcf448301ee9ffd392" title="Dynamically allocates a continuous region of memory. ">malloc()</a>.  <a href="#a7619b847aeded8a6d14cbfa212b2cdfb">More...</a><br /></td></tr>
<tr class="separator:a7619b847aeded8a6d14cbfa212b2cdfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ad677fd23d0774acf0b858096f14c54eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#ad677fd23d0774acf0b858096f14c54eb">k_strlen</a> (const char *str)</td></tr>
<tr class="memdesc:ad677fd23d0774acf0b858096f14c54eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the length of a string.  <a href="#ad677fd23d0774acf0b858096f14c54eb">More...</a><br /></td></tr>
<tr class="separator:ad677fd23d0774acf0b858096f14c54eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa975844c3752be598cbe656c3be7c79d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#aa975844c3752be598cbe656c3be7c79d">k_memcpy</a> (void *dst, const void *src, int len)</td></tr>
<tr class="memdesc:aa975844c3752be598cbe656c3be7c79d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies a region of memory of a specified length.  <a href="#aa975844c3752be598cbe656c3be7c79d">More...</a><br /></td></tr>
<tr class="separator:aa975844c3752be598cbe656c3be7c79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af222ffdb13057ff818cc0422e6499929"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#af222ffdb13057ff818cc0422e6499929">k_memcmp</a> (const void *b1, const void *b2, int len)</td></tr>
<tr class="memdesc:af222ffdb13057ff818cc0422e6499929"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two memory areas of specified length.  <a href="#af222ffdb13057ff818cc0422e6499929">More...</a><br /></td></tr>
<tr class="separator:af222ffdb13057ff818cc0422e6499929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61623fea0b3d96da57e082b7d9c032ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a61623fea0b3d96da57e082b7d9c032ed">k_memset</a> (const void *b, char fill, int len)</td></tr>
<tr class="memdesc:a61623fea0b3d96da57e082b7d9c032ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a memory region with a constant byte.  <a href="#a61623fea0b3d96da57e082b7d9c032ed">More...</a><br /></td></tr>
<tr class="separator:a61623fea0b3d96da57e082b7d9c032ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476fa8b29922cf1ab24cb49a57cd1667"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a476fa8b29922cf1ab24cb49a57cd1667">poke_b</a> (<a class="el" href="kernel_8h.html#a5de4d864680acdb06c6f6fe11cc3d7d8">MEM_ADDR</a> addr, <a class="el" href="kernel_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> value)</td></tr>
<tr class="memdesc:a476fa8b29922cf1ab24cb49a57cd1667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes 1 byte to memory at the specified memory address.  <a href="#a476fa8b29922cf1ab24cb49a57cd1667">More...</a><br /></td></tr>
<tr class="separator:a476fa8b29922cf1ab24cb49a57cd1667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3879aa37ac302cf88e706b93be197cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#ad3879aa37ac302cf88e706b93be197cb">poke_w</a> (<a class="el" href="kernel_8h.html#a5de4d864680acdb06c6f6fe11cc3d7d8">MEM_ADDR</a> addr, <a class="el" href="kernel_8h.html#a197942eefa7db30960ae396d68339b97">WORD</a> value)</td></tr>
<tr class="memdesc:ad3879aa37ac302cf88e706b93be197cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes 2 bytes to the memory region starting at the specified memory address.  <a href="#ad3879aa37ac302cf88e706b93be197cb">More...</a><br /></td></tr>
<tr class="separator:ad3879aa37ac302cf88e706b93be197cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89c27a57e5edfbab2cda145904016d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#ac89c27a57e5edfbab2cda145904016d1">poke_l</a> (<a class="el" href="kernel_8h.html#a5de4d864680acdb06c6f6fe11cc3d7d8">MEM_ADDR</a> addr, <a class="el" href="kernel_8h.html#a434cb264031f389cbbf1844726748ebc">LONG</a> value)</td></tr>
<tr class="memdesc:ac89c27a57e5edfbab2cda145904016d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes 4 bytes to the memory region starting at the specified memory address.  <a href="#ac89c27a57e5edfbab2cda145904016d1">More...</a><br /></td></tr>
<tr class="separator:ac89c27a57e5edfbab2cda145904016d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8f6e8a276b0399a61460880d4aec4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="kernel_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a4a8f6e8a276b0399a61460880d4aec4f">peek_b</a> (<a class="el" href="kernel_8h.html#a5de4d864680acdb06c6f6fe11cc3d7d8">MEM_ADDR</a> addr)</td></tr>
<tr class="memdesc:a4a8f6e8a276b0399a61460880d4aec4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 1 byte from the specified memory address.  <a href="#a4a8f6e8a276b0399a61460880d4aec4f">More...</a><br /></td></tr>
<tr class="separator:a4a8f6e8a276b0399a61460880d4aec4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c825cbb154f72071dd38cdac44ff47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="kernel_8h.html#a197942eefa7db30960ae396d68339b97">WORD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a89c825cbb154f72071dd38cdac44ff47">peek_w</a> (<a class="el" href="kernel_8h.html#a5de4d864680acdb06c6f6fe11cc3d7d8">MEM_ADDR</a> addr)</td></tr>
<tr class="memdesc:a89c825cbb154f72071dd38cdac44ff47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 2 bytes from the memory region starting at the specified memory address.  <a href="#a89c825cbb154f72071dd38cdac44ff47">More...</a><br /></td></tr>
<tr class="separator:a89c825cbb154f72071dd38cdac44ff47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1b9e00b9eafd82d022cb9ffd1dede4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="kernel_8h.html#a434cb264031f389cbbf1844726748ebc">LONG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a0c1b9e00b9eafd82d022cb9ffd1dede4">peek_l</a> (<a class="el" href="kernel_8h.html#a5de4d864680acdb06c6f6fe11cc3d7d8">MEM_ADDR</a> addr)</td></tr>
<tr class="memdesc:a0c1b9e00b9eafd82d022cb9ffd1dede4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads 4 bytes from the memory region starting at the specified memory address.  <a href="#a0c1b9e00b9eafd82d022cb9ffd1dede4">More...</a><br /></td></tr>
<tr class="separator:a0c1b9e00b9eafd82d022cb9ffd1dede4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ae83b120b2747f3791ef7bc743de62"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a88ae83b120b2747f3791ef7bc743de62">vsprintf</a> (char *buf, const char *fmt, va_list argp)</td></tr>
<tr class="memdesc:a88ae83b120b2747f3791ef7bc743de62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements formatted-print features of the <a class="el" href="kernel_8h.html#ae02cb6e6121bb801f5a6411769adc6ee" title="Prints content to a window in accordance with the specified format or conversion. ...">wprintf()</a> and <a class="el" href="kernel_8h.html#a199a1f701f4cc4fd1c3ff7903a102d7a" title="Prints content to the kernel_window in accordance with the specified format or conversion. ">kprintf()</a> functions.  <a href="#a88ae83b120b2747f3791ef7bc743de62">More...</a><br /></td></tr>
<tr class="separator:a88ae83b120b2747f3791ef7bc743de62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6dcfbefcba8307a0582eb19f633778a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#aa6dcfbefcba8307a0582eb19f633778a">move_cursor</a> (<a class="el" href="structWINDOW.html">WINDOW</a> *wnd, int x, int y)</td></tr>
<tr class="memdesc:aa6dcfbefcba8307a0582eb19f633778a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places the cursor at a specific position.  <a href="#aa6dcfbefcba8307a0582eb19f633778a">More...</a><br /></td></tr>
<tr class="separator:aa6dcfbefcba8307a0582eb19f633778a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab406d8dcb6b139a7d87d4feae5e66895"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#ab406d8dcb6b139a7d87d4feae5e66895">remove_cursor</a> (<a class="el" href="structWINDOW.html">WINDOW</a> *wnd)</td></tr>
<tr class="memdesc:ab406d8dcb6b139a7d87d4feae5e66895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the cursor from a window.  <a href="#ab406d8dcb6b139a7d87d4feae5e66895">More...</a><br /></td></tr>
<tr class="separator:ab406d8dcb6b139a7d87d4feae5e66895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f2037d58ac553379390c7966e09bf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a74f2037d58ac553379390c7966e09bf1">show_cursor</a> (<a class="el" href="structWINDOW.html">WINDOW</a> *wnd)</td></tr>
<tr class="memdesc:a74f2037d58ac553379390c7966e09bf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the cursor at the current cursor location.  <a href="#a74f2037d58ac553379390c7966e09bf1">More...</a><br /></td></tr>
<tr class="separator:a74f2037d58ac553379390c7966e09bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac67275347b6021ea8bd6b9db6a3a512"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#aac67275347b6021ea8bd6b9db6a3a512">clear_window</a> (<a class="el" href="structWINDOW.html">WINDOW</a> *wnd)</td></tr>
<tr class="memdesc:aac67275347b6021ea8bd6b9db6a3a512"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the contents of the window.  <a href="#aac67275347b6021ea8bd6b9db6a3a512">More...</a><br /></td></tr>
<tr class="separator:aac67275347b6021ea8bd6b9db6a3a512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f7518813d0820b8ec1c1392de01954"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a08f7518813d0820b8ec1c1392de01954">output_char</a> (<a class="el" href="structWINDOW.html">WINDOW</a> *wnd, unsigned char ch)</td></tr>
<tr class="memdesc:a08f7518813d0820b8ec1c1392de01954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays a character at the cursor location, and advances the cursor appropriately.  <a href="#a08f7518813d0820b8ec1c1392de01954">More...</a><br /></td></tr>
<tr class="separator:a08f7518813d0820b8ec1c1392de01954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae430920aa5940d9c9e34a5ec6e5c1ed8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#ae430920aa5940d9c9e34a5ec6e5c1ed8">output_string</a> (<a class="el" href="structWINDOW.html">WINDOW</a> *wnd, const char *str)</td></tr>
<tr class="memdesc:ae430920aa5940d9c9e34a5ec6e5c1ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays a string starting at the cursor location, and advances the cursor appropriately after the end of the string.  <a href="#ae430920aa5940d9c9e34a5ec6e5c1ed8">More...</a><br /></td></tr>
<tr class="separator:ae430920aa5940d9c9e34a5ec6e5c1ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02cb6e6121bb801f5a6411769adc6ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#ae02cb6e6121bb801f5a6411769adc6ee">wprintf</a> (<a class="el" href="structWINDOW.html">WINDOW</a> *wnd, const char *fmt,...)</td></tr>
<tr class="memdesc:ae02cb6e6121bb801f5a6411769adc6ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints content to a window in accordance with the specified format or conversion.  <a href="#ae02cb6e6121bb801f5a6411769adc6ee">More...</a><br /></td></tr>
<tr class="separator:ae02cb6e6121bb801f5a6411769adc6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199a1f701f4cc4fd1c3ff7903a102d7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a199a1f701f4cc4fd1c3ff7903a102d7a">kprintf</a> (const char *fmt,...)</td></tr>
<tr class="memdesc:a199a1f701f4cc4fd1c3ff7903a102d7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints content to the <a class="el" href="kernel_8h.html#aeb93d089146101ad08f141c0fc2c6b15" title="Pointer to a WINDOW struct for a window that covers the entire screen. ">kernel_window</a> in accordance with the specified format or conversion.  <a href="#a199a1f701f4cc4fd1c3ff7903a102d7a">More...</a><br /></td></tr>
<tr class="separator:a199a1f701f4cc4fd1c3ff7903a102d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae982573084c63244f2b0c4f8acb043f7"><td class="memItemLeft" align="right" valign="top">PORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#ae982573084c63244f2b0c4f8acb043f7">create_process</a> (void(*new_proc)(<a class="el" href="kernel_8h.html#a831d87f38811800ce0698bbe85e6b386">PROCESS</a>, <a class="el" href="kernel_8h.html#a83f26503eb4a201692c1e8d8bb2e168d">PARAM</a>), int prio, <a class="el" href="kernel_8h.html#a83f26503eb4a201692c1e8d8bb2e168d">PARAM</a> param, char *proc_name)</td></tr>
<tr class="memdesc:ae982573084c63244f2b0c4f8acb043f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new TOS process and returns the <a class="el" href="struct__PORT__DEF.html">PORT</a> owned by the new process (or, before ports are covered, returns a NULL pointer).  <a href="#ae982573084c63244f2b0c4f8acb043f7">More...</a><br /></td></tr>
<tr class="separator:ae982573084c63244f2b0c4f8acb043f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba03cb110510187d40043ffd1352d57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a0ba03cb110510187d40043ffd1352d57">print_process</a> (<a class="el" href="structWINDOW.html">WINDOW</a> *wnd, <a class="el" href="kernel_8h.html#a831d87f38811800ce0698bbe85e6b386">PROCESS</a> p)</td></tr>
<tr class="memdesc:a0ba03cb110510187d40043ffd1352d57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the details of the specified TOS process.  <a href="#a0ba03cb110510187d40043ffd1352d57">More...</a><br /></td></tr>
<tr class="separator:a0ba03cb110510187d40043ffd1352d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae816c773af94e99847e12d847fe1b252"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#ae816c773af94e99847e12d847fe1b252">print_all_processes</a> (<a class="el" href="structWINDOW.html">WINDOW</a> *wnd)</td></tr>
<tr class="memdesc:ae816c773af94e99847e12d847fe1b252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the details of all existing TOS processes.  <a href="#ae816c773af94e99847e12d847fe1b252">More...</a><br /></td></tr>
<tr class="separator:ae816c773af94e99847e12d847fe1b252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25d44702b6e10e723714c368c4a7520"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#ab25d44702b6e10e723714c368c4a7520">init_process</a> ()</td></tr>
<tr class="memdesc:ab25d44702b6e10e723714c368c4a7520"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the global variables associated with TOS process creation.  <a href="#ab25d44702b6e10e723714c368c4a7520">More...</a><br /></td></tr>
<tr class="separator:ab25d44702b6e10e723714c368c4a7520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b26baa874c4de9d0db0020a495f307e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="kernel_8h.html#a831d87f38811800ce0698bbe85e6b386">PROCESS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a3b26baa874c4de9d0db0020a495f307e">dispatcher</a> ()</td></tr>
<tr class="memdesc:a3b26baa874c4de9d0db0020a495f307e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects and returns the next process to run.  <a href="#a3b26baa874c4de9d0db0020a495f307e">More...</a><br /></td></tr>
<tr class="separator:a3b26baa874c4de9d0db0020a495f307e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aeea7e226886cd1f41c19e26e94884e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a4aeea7e226886cd1f41c19e26e94884e">add_ready_queue</a> (<a class="el" href="kernel_8h.html#a831d87f38811800ce0698bbe85e6b386">PROCESS</a> proc)</td></tr>
<tr class="memdesc:a4aeea7e226886cd1f41c19e26e94884e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a process to the ready queue.  <a href="#a4aeea7e226886cd1f41c19e26e94884e">More...</a><br /></td></tr>
<tr class="separator:a4aeea7e226886cd1f41c19e26e94884e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9e82f9b4c35add01dad50fdf183e9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a1c9e82f9b4c35add01dad50fdf183e9a">remove_ready_queue</a> (<a class="el" href="kernel_8h.html#a831d87f38811800ce0698bbe85e6b386">PROCESS</a> proc)</td></tr>
<tr class="memdesc:a1c9e82f9b4c35add01dad50fdf183e9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes a process from the ready queue.  <a href="#a1c9e82f9b4c35add01dad50fdf183e9a">More...</a><br /></td></tr>
<tr class="separator:a1c9e82f9b4c35add01dad50fdf183e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2384e9e590e0ee81cc9818744b2144"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a8f2384e9e590e0ee81cc9818744b2144">become_zombie</a> ()</td></tr>
<tr class="memdesc:a8f2384e9e590e0ee81cc9818744b2144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the state of the calling process to <a class="el" href="kernel_8h.html#a8e13ad68fa4d5752084a5ef0e0085a66" title="This state is assigned to processes that are permanently off the ready_queue and will never run again...">STATE_ZOMBIE</a>.  <a href="#a8f2384e9e590e0ee81cc9818744b2144">More...</a><br /></td></tr>
<tr class="separator:a8f2384e9e590e0ee81cc9818744b2144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae42c37d7e61697646625aafaeae957"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#aaae42c37d7e61697646625aafaeae957">resign</a> ()</td></tr>
<tr class="memdesc:aaae42c37d7e61697646625aafaeae957"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a context switch in TOS, giving another process a chance to run.  <a href="#aaae42c37d7e61697646625aafaeae957">More...</a><br /></td></tr>
<tr class="separator:aaae42c37d7e61697646625aafaeae957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9a52d032bce03b717484ec230ece45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a6b9a52d032bce03b717484ec230ece45">init_dispatcher</a> ()</td></tr>
<tr class="memdesc:a6b9a52d032bce03b717484ec230ece45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the global variables associated with the ready queue.  <a href="#a6b9a52d032bce03b717484ec230ece45">More...</a><br /></td></tr>
<tr class="separator:a6b9a52d032bce03b717484ec230ece45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11dd35e7b561c664f6b9deca1c30444a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a11dd35e7b561c664f6b9deca1c30444a">init_null_process</a> ()</td></tr>
<tr class="memdesc:a11dd35e7b561c664f6b9deca1c30444a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the null process.  <a href="#a11dd35e7b561c664f6b9deca1c30444a">More...</a><br /></td></tr>
<tr class="separator:a11dd35e7b561c664f6b9deca1c30444a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d255ea2fe47c5ee2c757bf6416227d"><td class="memItemLeft" align="right" valign="top">PORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#ae9d255ea2fe47c5ee2c757bf6416227d">create_port</a> ()</td></tr>
<tr class="memdesc:ae9d255ea2fe47c5ee2c757bf6416227d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new port for the calling process.  <a href="#ae9d255ea2fe47c5ee2c757bf6416227d">More...</a><br /></td></tr>
<tr class="separator:ae9d255ea2fe47c5ee2c757bf6416227d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191b96a6ebaa20de1b58bcd3956bbcd8"><td class="memItemLeft" align="right" valign="top">PORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a191b96a6ebaa20de1b58bcd3956bbcd8">create_new_port</a> (<a class="el" href="kernel_8h.html#a831d87f38811800ce0698bbe85e6b386">PROCESS</a> proc)</td></tr>
<tr class="memdesc:a191b96a6ebaa20de1b58bcd3956bbcd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new port for the process indicated by the parameter proc.  <a href="#a191b96a6ebaa20de1b58bcd3956bbcd8">More...</a><br /></td></tr>
<tr class="separator:a191b96a6ebaa20de1b58bcd3956bbcd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f22fb991371149226f31ddf10f47795"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a3f22fb991371149226f31ddf10f47795">open_port</a> (PORT port)</td></tr>
<tr class="memdesc:a3f22fb991371149226f31ddf10f47795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens a port.  <a href="#a3f22fb991371149226f31ddf10f47795">More...</a><br /></td></tr>
<tr class="separator:a3f22fb991371149226f31ddf10f47795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2213e4e559d438d23552fbd3c2a107a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#ad2213e4e559d438d23552fbd3c2a107a">close_port</a> (PORT port)</td></tr>
<tr class="memdesc:ad2213e4e559d438d23552fbd3c2a107a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a port.  <a href="#ad2213e4e559d438d23552fbd3c2a107a">More...</a><br /></td></tr>
<tr class="separator:ad2213e4e559d438d23552fbd3c2a107a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e779a204bd7960376d8f122d5afd5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a70e779a204bd7960376d8f122d5afd5a">send</a> (PORT dest_port, void *data)</td></tr>
<tr class="memdesc:a70e779a204bd7960376d8f122d5afd5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message to the <a class="el" href="struct__PORT__DEF.html">PORT</a> of a receiver process, and a reply to the message is expected.  <a href="#a70e779a204bd7960376d8f122d5afd5a">More...</a><br /></td></tr>
<tr class="separator:a70e779a204bd7960376d8f122d5afd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacc4f7df1c840c0e6f109dfde5ff934f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#aacc4f7df1c840c0e6f109dfde5ff934f">message</a> (PORT dest_port, void *data)</td></tr>
<tr class="memdesc:aacc4f7df1c840c0e6f109dfde5ff934f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a message to the <a class="el" href="struct__PORT__DEF.html">PORT</a> of a receiver process, from which no reply is expected.  <a href="#aacc4f7df1c840c0e6f109dfde5ff934f">More...</a><br /></td></tr>
<tr class="separator:aacc4f7df1c840c0e6f109dfde5ff934f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fe8a985abbaec28b7065d0ad3b3e80"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80">receive</a> (<a class="el" href="kernel_8h.html#a831d87f38811800ce0698bbe85e6b386">PROCESS</a> *sender)</td></tr>
<tr class="memdesc:a57fe8a985abbaec28b7065d0ad3b3e80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives a message.  <a href="#a57fe8a985abbaec28b7065d0ad3b3e80">More...</a><br /></td></tr>
<tr class="separator:a57fe8a985abbaec28b7065d0ad3b3e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae559b6ee61d6e596c651dde6028582"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#afae559b6ee61d6e596c651dde6028582">reply</a> (<a class="el" href="kernel_8h.html#a831d87f38811800ce0698bbe85e6b386">PROCESS</a> sender)</td></tr>
<tr class="memdesc:afae559b6ee61d6e596c651dde6028582"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replies to a message.  <a href="#afae559b6ee61d6e596c651dde6028582">More...</a><br /></td></tr>
<tr class="separator:afae559b6ee61d6e596c651dde6028582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab33da3342afdd7d505cae618be9d5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a7ab33da3342afdd7d505cae618be9d5c">init_ipc</a> ()</td></tr>
<tr class="memdesc:a7ab33da3342afdd7d505cae618be9d5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the global variables associated with inter-process communication.  <a href="#a7ab33da3342afdd7d505cae618be9d5c">More...</a><br /></td></tr>
<tr class="separator:a7ab33da3342afdd7d505cae618be9d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2a7dc4c8b814a7e11ffc87780df7d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#add2a7dc4c8b814a7e11ffc87780df7d7">init_idt_entry</a> (int intr_no, void(*isr)(void))</td></tr>
<tr class="memdesc:add2a7dc4c8b814a7e11ffc87780df7d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the <a class="el" href="structIDT.html" title="Holds the data fields associated with an x86 interrupt. ">IDT</a> entry for a single interrupt.  <a href="#add2a7dc4c8b814a7e11ffc87780df7d7">More...</a><br /></td></tr>
<tr class="separator:add2a7dc4c8b814a7e11ffc87780df7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c66a2884e17fb661a5a485dcca9e26f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a7c66a2884e17fb661a5a485dcca9e26f">wait_for_interrupt</a> (int intr_no)</td></tr>
<tr class="memdesc:a7c66a2884e17fb661a5a485dcca9e26f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Causes a process to wait until the specified interrupt occurs.  <a href="#a7c66a2884e17fb661a5a485dcca9e26f">More...</a><br /></td></tr>
<tr class="separator:a7c66a2884e17fb661a5a485dcca9e26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ada49c1954d38252049786595d9a5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a88ada49c1954d38252049786595d9a5f">init_interrupts</a> ()</td></tr>
<tr class="memdesc:a88ada49c1954d38252049786595d9a5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the interrupt subsystem of TOS.  <a href="#a88ada49c1954d38252049786595d9a5f">More...</a><br /></td></tr>
<tr class="separator:a88ada49c1954d38252049786595d9a5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8ece954c7a70eb04493321c6e46f3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a2d8ece954c7a70eb04493321c6e46f3c">sleep</a> (int num_of_ticks)</td></tr>
<tr class="memdesc:a2d8ece954c7a70eb04493321c6e46f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts the calling process to sleep (off the ready queue) for a specified number of timer ticks.  <a href="#a2d8ece954c7a70eb04493321c6e46f3c">More...</a><br /></td></tr>
<tr class="separator:a2d8ece954c7a70eb04493321c6e46f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38016ab7b2931bcb950e0c6f3ba3f342"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a38016ab7b2931bcb950e0c6f3ba3f342">init_timer</a> ()</td></tr>
<tr class="memdesc:a38016ab7b2931bcb950e0c6f3ba3f342"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the timer process.  <a href="#a38016ab7b2931bcb950e0c6f3ba3f342">More...</a><br /></td></tr>
<tr class="separator:a38016ab7b2931bcb950e0c6f3ba3f342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60511a9660702b537d639a4096cd9988"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a60511a9660702b537d639a4096cd9988">inportb</a> (unsigned short port)</td></tr>
<tr class="memdesc:a60511a9660702b537d639a4096cd9988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a byte from the I/O port designated by the argument port.  <a href="#a60511a9660702b537d639a4096cd9988">More...</a><br /></td></tr>
<tr class="separator:a60511a9660702b537d639a4096cd9988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c698260d261a6984816b27db7a3398e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a5c698260d261a6984816b27db7a3398e">outportb</a> (unsigned short port, unsigned char value)</td></tr>
<tr class="memdesc:a5c698260d261a6984816b27db7a3398e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the byte value to the I/O port designated by the argument port.  <a href="#a5c698260d261a6984816b27db7a3398e">More...</a><br /></td></tr>
<tr class="separator:a5c698260d261a6984816b27db7a3398e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667529bb896d3107cb5d62f608dceaa5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a667529bb896d3107cb5d62f608dceaa5">init_com</a> ()</td></tr>
<tr class="memdesc:a667529bb896d3107cb5d62f608dceaa5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the COM subsystem of TOS.  <a href="#a667529bb896d3107cb5d62f608dceaa5">More...</a><br /></td></tr>
<tr class="separator:a667529bb896d3107cb5d62f608dceaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5703cd456b7a86eac9a03b4dce660b34"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a5703cd456b7a86eac9a03b4dce660b34">keyb_get_keystroke</a> (int window_id, <a class="el" href="kernel_8h.html#a050c65e107f0c828f856a231f4b4e788">BOOL</a> block)</td></tr>
<tr class="memdesc:a5703cd456b7a86eac9a03b4dce660b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queries the keyboard process for the next keystroke.  <a href="#a5703cd456b7a86eac9a03b4dce660b34">More...</a><br /></td></tr>
<tr class="separator:a5703cd456b7a86eac9a03b4dce660b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cd3acd7319667c875c62b570b9db49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a48cd3acd7319667c875c62b570b9db49">init_keyb</a> ()</td></tr>
<tr class="memdesc:a48cd3acd7319667c875c62b570b9db49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the keyboard process.  <a href="#a48cd3acd7319667c875c62b570b9db49">More...</a><br /></td></tr>
<tr class="separator:a48cd3acd7319667c875c62b570b9db49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a370c075a0550a77d5954725f01f96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a22a370c075a0550a77d5954725f01f96">start_shell</a> ()</td></tr>
<tr class="memdesc:a22a370c075a0550a77d5954725f01f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a new TOS shell window.  <a href="#a22a370c075a0550a77d5954725f01f96">More...</a><br /></td></tr>
<tr class="separator:a22a370c075a0550a77d5954725f01f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4d3133069013495ad0f53636b0d638d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#ab4d3133069013495ad0f53636b0d638d">init_train</a> ()</td></tr>
<tr class="memdesc:ab4d3133069013495ad0f53636b0d638d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a train process in TOS.  <a href="#ab4d3133069013495ad0f53636b0d638d">More...</a><br /></td></tr>
<tr class="separator:ab4d3133069013495ad0f53636b0d638d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4958487f6319a4e9deed6ae1962be3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a0d4958487f6319a4e9deed6ae1962be3">set_train_speed</a> (char *speed)</td></tr>
<tr class="memdesc:a0d4958487f6319a4e9deed6ae1962be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the speed of the model train.  <a href="#a0d4958487f6319a4e9deed6ae1962be3">More...</a><br /></td></tr>
<tr class="separator:a0d4958487f6319a4e9deed6ae1962be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac38fce3243a7dcf448301ee9ffd392"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a7ac38fce3243a7dcf448301ee9ffd392">malloc</a> (<a class="el" href="kernel_8h.html#a7619b847aeded8a6d14cbfa212b2cdfb">size_t</a> size)</td></tr>
<tr class="memdesc:a7ac38fce3243a7dcf448301ee9ffd392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamically allocates a continuous region of memory.  <a href="#a7ac38fce3243a7dcf448301ee9ffd392">More...</a><br /></td></tr>
<tr class="separator:a7ac38fce3243a7dcf448301ee9ffd392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbedc913aa4651b3c3b4b3aecd9b4711"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#afbedc913aa4651b3c3b4b3aecd9b4711">free</a> (void *ptr)</td></tr>
<tr class="memdesc:afbedc913aa4651b3c3b4b3aecd9b4711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees a previously-allocated region of memory.  <a href="#afbedc913aa4651b3c3b4b3aecd9b4711">More...</a><br /></td></tr>
<tr class="separator:afbedc913aa4651b3c3b4b3aecd9b4711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee6330fe2c39feda7b1a2e909452db5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a8ee6330fe2c39feda7b1a2e909452db5">wm_create</a> (int x, int y, int width, int height)</td></tr>
<tr class="memdesc:a8ee6330fe2c39feda7b1a2e909452db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new window via the Window Manager service.  <a href="#a8ee6330fe2c39feda7b1a2e909452db5">More...</a><br /></td></tr>
<tr class="separator:a8ee6330fe2c39feda7b1a2e909452db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960a429457157abb6b3ecbbec4c8a243"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a960a429457157abb6b3ecbbec4c8a243">wm_clear</a> (int window_id)</td></tr>
<tr class="memdesc:a960a429457157abb6b3ecbbec4c8a243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the window and places the cursor in the top left corner of the window.  <a href="#a960a429457157abb6b3ecbbec4c8a243">More...</a><br /></td></tr>
<tr class="separator:a960a429457157abb6b3ecbbec4c8a243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a107a138b4d263da9906636004b9cdf28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a107a138b4d263da9906636004b9cdf28">wm_set_cursor</a> (int window_id, int x, int y, char ch)</td></tr>
<tr class="memdesc:a107a138b4d263da9906636004b9cdf28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the cursor to a given position in the window.  <a href="#a107a138b4d263da9906636004b9cdf28">More...</a><br /></td></tr>
<tr class="separator:a107a138b4d263da9906636004b9cdf28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c52bde65decfbe97201240835205c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#ad7c52bde65decfbe97201240835205c0">wm_print</a> (int window_id, const char *fmt,...)</td></tr>
<tr class="memdesc:ad7c52bde65decfbe97201240835205c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primts a formatted string to the window.  <a href="#ad7c52bde65decfbe97201240835205c0">More...</a><br /></td></tr>
<tr class="separator:ad7c52bde65decfbe97201240835205c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee9719f3126c238ba343ac0d6b40d6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#adee9719f3126c238ba343ac0d6b40d6a">init_wm</a> ()</td></tr>
<tr class="memdesc:adee9719f3126c238ba343ac0d6b40d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the Window Manager service.  <a href="#adee9719f3126c238ba343ac0d6b40d6a">More...</a><br /></td></tr>
<tr class="separator:adee9719f3126c238ba343ac0d6b40d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85f715505e3c0142953633dc5f7b763"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#af85f715505e3c0142953633dc5f7b763">start_pong</a> ()</td></tr>
<tr class="memdesc:af85f715505e3c0142953633dc5f7b763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Starts a new game of pong.  <a href="#af85f715505e3c0142953633dc5f7b763">More...</a><br /></td></tr>
<tr class="separator:af85f715505e3c0142953633dc5f7b763"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aeb93d089146101ad08f141c0fc2c6b15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structWINDOW.html">WINDOW</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#aeb93d089146101ad08f141c0fc2c6b15">kernel_window</a></td></tr>
<tr class="memdesc:aeb93d089146101ad08f141c0fc2c6b15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to a <a class="el" href="structWINDOW.html" title="Contains the properties of a specific window. ">WINDOW</a> struct for a window that covers the entire screen.  <a href="#aeb93d089146101ad08f141c0fc2c6b15">More...</a><br /></td></tr>
<tr class="separator:aeb93d089146101ad08f141c0fc2c6b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e64f2ad93cc9de92000f884e6e0a8a9"><td class="memItemLeft" align="right" valign="top">PCB&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a5e64f2ad93cc9de92000f884e6e0a8a9">pcb</a> []</td></tr>
<tr class="memdesc:a5e64f2ad93cc9de92000f884e6e0a8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array of twenty <a class="el" href="struct__PCB.html">PCB</a> structs.  <a href="#a5e64f2ad93cc9de92000f884e6e0a8a9">More...</a><br /></td></tr>
<tr class="separator:a5e64f2ad93cc9de92000f884e6e0a8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087ab3f9b5dff3f23f91a1b6e66e5072"><td class="memItemLeft" align="right" valign="top"><a class="el" href="kernel_8h.html#a831d87f38811800ce0698bbe85e6b386">PROCESS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a087ab3f9b5dff3f23f91a1b6e66e5072">active_proc</a></td></tr>
<tr class="memdesc:a087ab3f9b5dff3f23f91a1b6e66e5072"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actively-running process.  <a href="#a087ab3f9b5dff3f23f91a1b6e66e5072">More...</a><br /></td></tr>
<tr class="separator:a087ab3f9b5dff3f23f91a1b6e66e5072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e099987c910c0a74ddb26ffe7b1774"><td class="memItemLeft" align="right" valign="top">PCB *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#ab4e099987c910c0a74ddb26ffe7b1774">ready_queue</a> []</td></tr>
<tr class="memdesc:ab4e099987c910c0a74ddb26ffe7b1774"><td class="mdescLeft">&#160;</td><td class="mdescRight">An array of pointers to PCBs for those processes that are ready to use CPU cycles.  <a href="#ab4e099987c910c0a74ddb26ffe7b1774">More...</a><br /></td></tr>
<tr class="separator:ab4e099987c910c0a74ddb26ffe7b1774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380792ed8611865e8009047a3fee62b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="kernel_8h.html#a050c65e107f0c828f856a231f4b4e788">BOOL</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a380792ed8611865e8009047a3fee62b5">interrupts_initialized</a></td></tr>
<tr class="memdesc:a380792ed8611865e8009047a3fee62b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A global variable indicating whether interrupts are enabled (TRUE) or disabled (FALSE).  <a href="#a380792ed8611865e8009047a3fee62b5">More...</a><br /></td></tr>
<tr class="separator:a380792ed8611865e8009047a3fee62b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7271a38be80889290a3b624f3d6bad83"><td class="memItemLeft" align="right" valign="top">PORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a7271a38be80889290a3b624f3d6bad83">timer_port</a></td></tr>
<tr class="memdesc:a7271a38be80889290a3b624f3d6bad83"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="struct__PORT__DEF.html">PORT</a> owned by the timer process.  <a href="#a7271a38be80889290a3b624f3d6bad83">More...</a><br /></td></tr>
<tr class="separator:a7271a38be80889290a3b624f3d6bad83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3235fc563e60489c99c3a3959ead5f24"><td class="memItemLeft" align="right" valign="top">PORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#a3235fc563e60489c99c3a3959ead5f24">com_port</a></td></tr>
<tr class="memdesc:a3235fc563e60489c99c3a3959ead5f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="struct__PORT__DEF.html">PORT</a> owned by the COM process to receive messages from user processes.  <a href="#a3235fc563e60489c99c3a3959ead5f24">More...</a><br /></td></tr>
<tr class="separator:a3235fc563e60489c99c3a3959ead5f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc32d8217e2da0da36dc851cbc97cdac"><td class="memItemLeft" align="right" valign="top">PORT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="kernel_8h.html#afc32d8217e2da0da36dc851cbc97cdac">keyb_port</a></td></tr>
<tr class="memdesc:afc32d8217e2da0da36dc851cbc97cdac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="struct__PORT__DEF.html">PORT</a> owned by the keyboard process.  <a href="#afc32d8217e2da0da36dc851cbc97cdac">More...</a><br /></td></tr>
<tr class="separator:afc32d8217e2da0da36dc851cbc97cdac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header file for the TOS kernel. </p>
<p>This header file defines many variables, typedefs, structs, and functions that are used throughout the TOS API. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a3685c78b9bd6dd0fa3861807e24a4e1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COM1_IRQ&#160;&#160;&#160;0x64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number associated with a COM1 interrupt. </p>
<p>In TOS the interrupt controller is re-programmed so that the COM1 interrupt is mapped to interrupt number 0x64. COM1 is the port used to communicate with the model train. </p>

</div>
</div>
<a class="anchor" id="a8982f081d8608e775b0739cde65373d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COM1_PORT&#160;&#160;&#160;0x3f8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The base address of the I/O ports associated with COM1. </p>
<p>It is important to note that these I/O ports are not to be confused with a <a class="el" href="struct__PORT__DEF.html">PORT</a> used by TOS processes for inter-process communication. </p>

</div>
</div>
<a class="anchor" id="ab02d84052a299a0c207a8ea4c1a5636d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COM2_IRQ&#160;&#160;&#160;0x63</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number associated with a COM2 interrupt. </p>
<p>In TOS the interrupt controller is re-programmed so that the COM2 interrupt is mapped to interrupt number 0x63. COM2 is used to communicate with the TOS Test Center. </p>

</div>
</div>
<a class="anchor" id="a88373c3e34a242356333ec08389eae54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define COM2_PORT&#160;&#160;&#160;0x2f8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The base address of the I/O ports associated with COM2. </p>
<p>It is important to note that these I/O ports are not to be confused with the <a class="el" href="struct__PORT__DEF.html">PORT</a> used by TOS processes for inter-process communication. </p>

</div>
</div>
<a class="anchor" id="a532d7d98780162a882090e6c0e1e36fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DISABLE_INTR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">save</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">asm</span> (<span class="stringliteral">&quot;pushfl&quot;</span>);                   \</div><div class="line">                                asm (<span class="stringliteral">&quot;popl %0&quot;</span> : <span class="stringliteral">&quot;=r&quot;</span> (save) : ); \</div><div class="line">                asm (<span class="stringliteral">&quot;cli&quot;</span>);</div></div><!-- fragment -->
<p>Assembly instructions that disable the interrupt subsystem of TOS to avoid race conditions. </p>
<p>When interrupts are enabled in TOS, a context switch can occur between any two machine instructions in response to an interrupt being raised. This condition is a problem, because many TOS functions contain critical sections that can lead to race conditions if a context switch happens at an unfortunate time. This problem is addressed by disabling interrupts while in the critical sections of these functions. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a529e0c1767f0b71a5269eeb7b09528cf" title="Assembly instructions that enable the interrupt subsystem of TOS. ">ENABLE_INTR</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a529e0c1767f0b71a5269eeb7b09528cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENABLE_INTR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">save</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">asm</span> (<span class="stringliteral">&quot;pushl %0&quot;</span> : : <span class="stringliteral">&quot;m&quot;</span> (save)); \</div><div class="line">                asm (<span class="stringliteral">&quot;popfl&quot;</span>);</div></div><!-- fragment -->
<p>Assembly instructions that enable the interrupt subsystem of TOS. </p>
<p>Many TOS functions have critical sections that can lead to race conditions if a context switch happens at an unfortunate time. To address this problem, the interrupt subsystem is temporarily disabled while a critical section of code is being executed. These assembly instructions re-enable it once the critical section has been completed. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a532d7d98780162a882090e6c0e1e36fe" title="Assembly instructions that disable the interrupt subsystem of TOS to avoid race conditions. ">DISABLE_INTR</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a77db186991bef443443f3a7414e4d84e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define IDT_ENTRY_SIZE&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of bytes of an entry in the Interrupt Descriptor Table ("IDT"). </p>
<p>The <a class="el" href="structIDT.html" title="Holds the data fields associated with an x86 interrupt. ">IDT</a> is a 256-element array, where each element is the descriptor for one interrupt supported by the x86. Each descriptor is an 8-byte data structure with information about (1) the selector and (2) offset for the ISR that handles the interrupt, and (3) attributes of that interrupt. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a9affc80dd8947cc1dcb1ae52801923c8" title="The number of elements in the Interrupt Descriptor Table (&quot;IDT&quot;). ">MAX_INTERRUPTS</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab1cd1e736761fd2efc00615782a271e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define KEYB_IRQ&#160;&#160;&#160;0x61</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number associated with a keyboard interrupt. </p>
<p>In TOS the interrupt controller is re-programmed so that the timer interrupt is mapped to interrupt number 0x61. </p>

</div>
</div>
<a class="anchor" id="a558a765eeee1053f8664ea223e85dd95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAGIC_PCB&#160;&#160;&#160;0x4321dcba</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A value used to verify that a data structure being accessed is a <a class="el" href="struct__PCB.html">PCB</a>. </p>
<p>"MAGIC" codes are used in TOS as a debugging and security feature in assert() statements. <a class="el" href="struct__PCB.html">PCB</a> structures store this value in a field. When a process attempts to access a PCB, this field is used to verify that the data structure being accessed is in fact a PCB. Failure of this condition stops execution of TOS. </p>

</div>
</div>
<a class="anchor" id="a5a7162a4cf2bc5e6950e2bf63c1ca47d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAGIC_PORT&#160;&#160;&#160;0x1234abcd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A value used to verify that a data structure being accessed is a <a class="el" href="struct__PORT__DEF.html">PORT</a>. </p>
<p>"MAGIC" codes are used in TOS as a debugging and security feature in assert() statements. Each <a class="el" href="struct__PORT__DEF.html">PORT</a> stores this value in its "magic" field. When a process attempts to access a <a class="el" href="struct__PORT__DEF.html">PORT</a>, this field is used to verify that the data structure being accessed is in fact a <a class="el" href="struct__PORT__DEF.html">PORT</a>. Failure of this condition stops execution of TOS. </p>

</div>
</div>
<a class="anchor" id="a9affc80dd8947cc1dcb1ae52801923c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_INTERRUPTS&#160;&#160;&#160;256</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of elements in the Interrupt Descriptor Table ("IDT"). </p>
<p>The <a class="el" href="structIDT.html" title="Holds the data fields associated with an x86 interrupt. ">IDT</a> is an array of 256 elements, where each element is a descriptor for one x86-supported interrupt. When the interrupt subsystem of TOS is initialized, this array is created and each of its elements is initialized with an entry describing the associated interrupt. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a77db186991bef443443f3a7414e4d84e" title="The number of bytes of an entry in the Interrupt Descriptor Table (&quot;IDT&quot;). ">IDT_ENTRY_SIZE</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a40ad70cc6e2125af9340a4bc26a83764"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_PORTS&#160;&#160;&#160;(<a class="el" href="kernel_8h.html#a0e92bfcd9e51ca39bbebc3dfb9c16014">MAX_PROCS</a> * 2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the maximum number of <a class="el" href="struct__PORT__DEF.html">PORT</a>s supported in TOS. </p>
<p>In the inter-process communication of TOS, messages are delivered to ports. Each TOS process can have one or more ports, but each port can be owned by exactly one process. This number is the size of the array that holds the <a class="el" href="struct__PORT__DEF.html">PORT</a> entries. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="struct__PORT__DEF.html">PORT</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0e92bfcd9e51ca39bbebc3dfb9c16014"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_PROCS&#160;&#160;&#160;20</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the maximum number of TOS processes that can be created. </p>
<p>Processes in TOS can be created, but are never deleted. There is a <a class="el" href="struct__PCB.html">PCB</a> entry for every TOS process. These entries are never deleted; once a process's <a class="el" href="struct__PCB.html">PCB</a> entry is created, it is never removed. After a TOS process has accomplished its task, the state of the TOS process can be changed to <a class="el" href="kernel_8h.html#a8e13ad68fa4d5752084a5ef0e0085a66" title="This state is assigned to processes that are permanently off the ready_queue and will never run again...">STATE_ZOMBIE</a> to indicate that it will not run again. </p>

</div>
</div>
<a class="anchor" id="aecc7a460bafe08baeb6b29065dd4f7c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX_READY_QUEUES&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the number of elements in the array which implements the <a class="el" href="kernel_8h.html#ab4e099987c910c0a74ddb26ffe7b1774" title="An array of pointers to PCBs for those processes that are ready to use CPU cycles. ">ready_queue</a>. </p>
<p>Processes in TOS are given priorities when they are created. Permitted priority levels are 0 through 7. Each of these priority numbers corresponds to one of the elements in the <a class="el" href="kernel_8h.html#ab4e099987c910c0a74ddb26ffe7b1774" title="An array of pointers to PCBs for those processes that are ready to use CPU cycles. ">ready_queue</a> array. Each element in that array is a pointer to a TOS process which is at the head of a doubly-linked list of existing TOS processes at that priority level. </p>

</div>
</div>
<a class="anchor" id="a81b88515a00640cd5475dc031dc4424b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STATE_INTR_BLOCKED&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This state is assigned to a process that is waiting for an interrupt to occur. </p>
<p>TOS utilizes keyboard interrupts, timer interrupts, and COM1 interrupts to accomplish various functions. A TOS process that is waiting for any of these interrupts is placed into this state and remains off the <a class="el" href="kernel_8h.html#ab4e099987c910c0a74ddb26ffe7b1774" title="An array of pointers to PCBs for those processes that are ready to use CPU cycles. ">ready_queue</a>. When the interrupt occurs, the process is changed to <a class="el" href="kernel_8h.html#aa74af0876332d1a6258cff9745a1bd53" title="This state is assigned to processes that are eligible to run and are ready to use CPU cycles...">STATE_READY</a> and put back on the ready queue so that it can resume activity. </p>

</div>
</div>
<a class="anchor" id="a16679ae7e3517177c16893143870a20f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STATE_MESSAGE_BLOCKED&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This state is assigned to a process that has called <a class="el" href="kernel_8h.html#aacc4f7df1c840c0e6f109dfde5ff934f" title="Sends a message to the PORT of a receiver process, from which no reply is expected. ">message()</a>, and the receiver process has not yet called <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a>. </p>
<p>In inter-process communication, if a TOS process calls <a class="el" href="kernel_8h.html#aacc4f7df1c840c0e6f109dfde5ff934f" title="Sends a message to the PORT of a receiver process, from which no reply is expected. ">message()</a> but the receiver process has not yet called <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a>, it means that the receiver is not ready to receive the message, and the sender process must wait until the receiver calls <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a>. Until the receiver calls <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a>, the sender process waits in this blocked state and is off the <a class="el" href="kernel_8h.html#ab4e099987c910c0a74ddb26ffe7b1774" title="An array of pointers to PCBs for those processes that are ready to use CPU cycles. ">ready_queue</a>. Unlike <a class="el" href="kernel_8h.html#ac2a702a7f1c65e77a83166f4642ae6e7" title="This state is assigned to a process that has called send(), but the receiver process has not yet call...">STATE_SEND_BLOCKED</a>, a process in this state does not expect a reply from the receiver, so that when the receiver calls <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a>, a <a class="el" href="kernel_8h.html#a16679ae7e3517177c16893143870a20f" title="This state is assigned to a process that has called message(), and the receiver process has not yet c...">STATE_MESSAGE_BLOCKED</a> process can be changed to <a class="el" href="kernel_8h.html#aa74af0876332d1a6258cff9745a1bd53" title="This state is assigned to processes that are eligible to run and are ready to use CPU cycles...">STATE_READY</a> and be put back on the ready queue. </p>

</div>
</div>
<a class="anchor" id="aa74af0876332d1a6258cff9745a1bd53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STATE_READY&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This state is assigned to processes that are eligible to run and are ready to use CPU cycles. </p>
<p>Only processes with this state can be on the <a class="el" href="kernel_8h.html#ab4e099987c910c0a74ddb26ffe7b1774" title="An array of pointers to PCBs for those processes that are ready to use CPU cycles. ">ready_queue</a>. If a process is in any other state, it is not eligible for CPU cycles and must be off the ready_queue. </p>

</div>
</div>
<a class="anchor" id="ac08fbd3b65bb3ea13b91882b70606e0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STATE_RECEIVE_BLOCKED&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This state is assigned to a process that has called <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a>, but there are no messages pending from any other process. </p>
<p>In inter-process communication, if a TOS process calls <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a> but no other process has sent it a message (either via <a class="el" href="kernel_8h.html#a70e779a204bd7960376d8f122d5afd5a" title="Sends a message to the PORT of a receiver process, and a reply to the message is expected. ">send()</a> or <a class="el" href="kernel_8h.html#aacc4f7df1c840c0e6f109dfde5ff934f" title="Sends a message to the PORT of a receiver process, from which no reply is expected. ">message()</a>), then the process that called <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a> enters this blocked state in order to await the sending of a message by another process. While receive-blocked, the process is off the <a class="el" href="kernel_8h.html#ab4e099987c910c0a74ddb26ffe7b1774" title="An array of pointers to PCBs for those processes that are ready to use CPU cycles. ">ready_queue</a>. Once another process sends a message via either <a class="el" href="kernel_8h.html#a70e779a204bd7960376d8f122d5afd5a" title="Sends a message to the PORT of a receiver process, and a reply to the message is expected. ">send()</a> or <a class="el" href="kernel_8h.html#aacc4f7df1c840c0e6f109dfde5ff934f" title="Sends a message to the PORT of a receiver process, from which no reply is expected. ">message()</a> to this process while this process is receive-blocked, then this process goes from receive-blocked to <a class="el" href="kernel_8h.html#aa74af0876332d1a6258cff9745a1bd53" title="This state is assigned to processes that are eligible to run and are ready to use CPU cycles...">STATE_READY</a>. </p>

</div>
</div>
<a class="anchor" id="a600b8498ae32f931e812309e3ea0b715"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STATE_REPLY_BLOCKED&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This state is assigned to a sending process in the situation where the process has called <a class="el" href="kernel_8h.html#a70e779a204bd7960376d8f122d5afd5a" title="Sends a message to the PORT of a receiver process, and a reply to the message is expected. ">send()</a> and the receiver process has called <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a> but not yet called <a class="el" href="kernel_8h.html#afae559b6ee61d6e596c651dde6028582" title="Replies to a message. ">reply()</a>. </p>
<p>When the sender uses <a class="el" href="kernel_8h.html#a70e779a204bd7960376d8f122d5afd5a" title="Sends a message to the PORT of a receiver process, and a reply to the message is expected. ">send()</a> instead of <a class="el" href="kernel_8h.html#aacc4f7df1c840c0e6f109dfde5ff934f" title="Sends a message to the PORT of a receiver process, from which no reply is expected. ">message()</a>, it is because the sender needs a reply from the receiver before the sender can be put back on the <a class="el" href="kernel_8h.html#ab4e099987c910c0a74ddb26ffe7b1774" title="An array of pointers to PCBs for those processes that are ready to use CPU cycles. ">ready_queue</a>. This state is used to indicate that the sender is awaiting a reply from the receiver process. After the receiver executes <a class="el" href="kernel_8h.html#afae559b6ee61d6e596c651dde6028582" title="Replies to a message. ">reply()</a>, the sender process goes from this state to <a class="el" href="kernel_8h.html#aa74af0876332d1a6258cff9745a1bd53" title="This state is assigned to processes that are eligible to run and are ready to use CPU cycles...">STATE_READY</a> and is put back on the ready queue. </p>

</div>
</div>
<a class="anchor" id="ac2a702a7f1c65e77a83166f4642ae6e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STATE_SEND_BLOCKED&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This state is assigned to a process that has called <a class="el" href="kernel_8h.html#a70e779a204bd7960376d8f122d5afd5a" title="Sends a message to the PORT of a receiver process, and a reply to the message is expected. ">send()</a>, but the receiver process has not yet called <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a>. </p>
<p>In inter-process communication, if a TOS process calls <a class="el" href="kernel_8h.html#a70e779a204bd7960376d8f122d5afd5a" title="Sends a message to the PORT of a receiver process, and a reply to the message is expected. ">send()</a> but the receiver process has not yet called <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a>, it means that the receiver is not ready to receive the message, and the sender process must wait until the receiver calls <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a>. Until the receiver calls <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a>, the sender process waits in this blocked state and is off the <a class="el" href="kernel_8h.html#ab4e099987c910c0a74ddb26ffe7b1774" title="An array of pointers to PCBs for those processes that are ready to use CPU cycles. ">ready_queue</a>. Unlike <a class="el" href="kernel_8h.html#a16679ae7e3517177c16893143870a20f" title="This state is assigned to a process that has called message(), and the receiver process has not yet c...">STATE_MESSAGE_BLOCKED</a>, a process in this state will not go back to <a class="el" href="kernel_8h.html#aa74af0876332d1a6258cff9745a1bd53" title="This state is assigned to processes that are eligible to run and are ready to use CPU cycles...">STATE_READY</a> when the receiver calls <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a>; rather, a process in this state becomes <a class="el" href="kernel_8h.html#a600b8498ae32f931e812309e3ea0b715" title="This state is assigned to a sending process in the situation where the process has called send() and ...">STATE_REPLY_BLOCKED</a> and subsequently awaits a reply from the receiver. </p>

</div>
</div>
<a class="anchor" id="a8e13ad68fa4d5752084a5ef0e0085a66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STATE_ZOMBIE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This state is assigned to processes that are permanently off the <a class="el" href="kernel_8h.html#ab4e099987c910c0a74ddb26ffe7b1774" title="An array of pointers to PCBs for those processes that are ready to use CPU cycles. ">ready_queue</a> and will never run again. </p>
<p>Once a process has completed its task and has no need to ever run again, it should be removed permanently off the ready queue. Such processes are assigned this state, which is irreversible. </p>

</div>
</div>
<a class="anchor" id="a7095fb363d08f6646611f9a47806647b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TIMER_IRQ&#160;&#160;&#160;0x60</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number associated with a timer interrupt. </p>
<p>In TOS the interrupt controller is re-programmed so that the timer interrupt is mapped to interrupt number 0x60. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a050c65e107f0c828f856a231f4b4e788"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="kernel_8h.html#a050c65e107f0c828f856a231f4b4e788">BOOL</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for true/false values, as an integer. </p>
<p>Assigns the name BOOL as an alternative name for the integer data type. </p>

</div>
</div>
<a class="anchor" id="a4ae1dab0fb4b072a66584546209e7d58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned char <a class="el" href="kernel_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a single-byte data type. </p>
<p>BYTE is another name in TOS for the unsigned character data type. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a4ae1dab0fb4b072a66584546209e7d58" title="Typedef for a single-byte data type. ">BYTE</a>, <a class="el" href="kernel_8h.html#a197942eefa7db30960ae396d68339b97" title="Typedef for an unsigned 2-byte data type. ">WORD</a>, <a class="el" href="kernel_8h.html#a434cb264031f389cbbf1844726748ebc" title="Typedef for an unsigned 4-byte data type. ">LONG</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a434cb264031f389cbbf1844726748ebc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned <a class="el" href="kernel_8h.html#a434cb264031f389cbbf1844726748ebc">LONG</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for an unsigned 4-byte data type. </p>
<p>LONG is another name in TOS for the unsigned integer data type. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a5de4d864680acdb06c6f6fe11cc3d7d8" title="Typedef for memory addresses within the main memory used by TOS. ">MEM_ADDR</a>, <a class="el" href="kernel_8h.html#a4ae1dab0fb4b072a66584546209e7d58" title="Typedef for a single-byte data type. ">BYTE</a>, <a class="el" href="kernel_8h.html#a197942eefa7db30960ae396d68339b97" title="Typedef for an unsigned 2-byte data type. ">WORD</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5de4d864680acdb06c6f6fe11cc3d7d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned <a class="el" href="kernel_8h.html#a5de4d864680acdb06c6f6fe11cc3d7d8">MEM_ADDR</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for memory addresses within the main memory used by TOS. </p>
<p>The MEM_ADDR type, like all pointers in the TOS API, is 4 bytes. </p>

</div>
</div>
<a class="anchor" id="a83f26503eb4a201692c1e8d8bb2e168d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned <a class="el" href="kernel_8h.html#a83f26503eb4a201692c1e8d8bb2e168d">PARAM</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A typedef that creates the alternative name PARAM for an unsigned integer type. </p>
<p>PARAM can be used to pass an optional parameter to <a class="el" href="kernel_8h.html#ae982573084c63244f2b0c4f8acb043f7" title="Creates a new TOS process and returns the PORT owned by the new process (or, before ports are covered...">create_process()</a> so that the process that calls <a class="el" href="kernel_8h.html#ae982573084c63244f2b0c4f8acb043f7" title="Creates a new TOS process and returns the PORT owned by the new process (or, before ports are covered...">create_process()</a> can communicate the parameter to the new process. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#ae982573084c63244f2b0c4f8acb043f7" title="Creates a new TOS process and returns the PORT owned by the new process (or, before ports are covered...">create_process()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a831d87f38811800ce0698bbe85e6b386"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kernel_8h.html#a831d87f38811800ce0698bbe85e6b386">PROCESS</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for a pointer to a <a class="el" href="struct__PCB.html">PCB</a> struct. </p>
<p>The <a class="el" href="process_8c.html#aa13757c49c1256b766ebc3d259ed94a3">pcb</a> array holds a <a class="el" href="struct__PCB.html">PCB</a> entry for each process. This typedef allows PROCESS to be used as an alternative name for a pointer to a <a class="el" href="struct__PCB.html">PCB</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a5e64f2ad93cc9de92000f884e6e0a8a9" title="An array of twenty PCB structs. ">pcb</a>, <a class="el" href="struct__PCB.html">PCB</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7619b847aeded8a6d14cbfa212b2cdfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="kernel_8h.html#a7619b847aeded8a6d14cbfa212b2cdfb">size_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for an integer, representing the size in bytes of the memory region being requested from <a class="el" href="kernel_8h.html#a7ac38fce3243a7dcf448301ee9ffd392" title="Dynamically allocates a continuous region of memory. ">malloc()</a>. </p>
<p>This typedef creates size_t as an alternative name for the integer data type. The type size_t is the data type of the argument to <a class="el" href="kernel_8h.html#a7ac38fce3243a7dcf448301ee9ffd392" title="Dynamically allocates a continuous region of memory. ">malloc()</a> specifying how many bytes of memory from the high memory region (with addresses in the range 1-8 MB) are being requested by a calling process. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a7ac38fce3243a7dcf448301ee9ffd392" title="Dynamically allocates a continuous region of memory. ">malloc()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a197942eefa7db30960ae396d68339b97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned short <a class="el" href="kernel_8h.html#a197942eefa7db30960ae396d68339b97">WORD</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef for an unsigned 2-byte data type. </p>
<p>WORD is another name in TOS for the unsigned short data type. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a5de4d864680acdb06c6f6fe11cc3d7d8" title="Typedef for memory addresses within the main memory used by TOS. ">MEM_ADDR</a>, <a class="el" href="kernel_8h.html#a197942eefa7db30960ae396d68339b97" title="Typedef for an unsigned 2-byte data type. ">WORD</a>, <a class="el" href="kernel_8h.html#a434cb264031f389cbbf1844726748ebc" title="Typedef for an unsigned 4-byte data type. ">LONG</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a4aeea7e226886cd1f41c19e26e94884e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void add_ready_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_8h.html#a831d87f38811800ce0698bbe85e6b386">PROCESS</a>&#160;</td>
          <td class="paramname"><em>proc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a process to the ready queue. </p>
<p>This function changes the state of process proc to <a class="el" href="kernel_8h.html#aa74af0876332d1a6258cff9745a1bd53" title="This state is assigned to processes that are eligible to run and are ready to use CPU cycles...">STATE_READY</a> and adds the process into the ready queue, at the tail of the doubly-linked list of processes maintained by the ready queue for each of the possibly priority levels 0 through 7. For example, if proc is a process at priority 5, proc will be added to the ready queue at priority 5 by placing it at the tail of the doubly-linked list occupying priority 5 of the ready queue. See the lecture slide "Maintaining the Ready Queue" in the Processes slide deck for more information. The process to be added must be in <a class="el" href="kernel_8h.html#aa74af0876332d1a6258cff9745a1bd53" title="This state is assigned to processes that are eligible to run and are ready to use CPU cycles...">STATE_READY</a>. Processes in any other state are not eligible to use the CPU, so they should not be on the ready queue until their state becomes <a class="el" href="kernel_8h.html#aa74af0876332d1a6258cff9745a1bd53" title="This state is assigned to processes that are eligible to run and are ready to use CPU cycles...">STATE_READY</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">proc</td><td>Process to be added to the ready queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#ab4e099987c910c0a74ddb26ffe7b1774" title="An array of pointers to PCBs for those processes that are ready to use CPU cycles. ">ready_queue</a>, <a class="el" href="kernel_8h.html#a1c9e82f9b4c35add01dad50fdf183e9a" title="Removes a process from the ready queue. ">remove_ready_queue</a>, <a class="el" href="kernel_8h.html#a3b26baa874c4de9d0db0020a495f307e" title="Selects and returns the next process to run. ">dispatcher()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8f2384e9e590e0ee81cc9818744b2144"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void become_zombie </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the state of the calling process to <a class="el" href="kernel_8h.html#a8e13ad68fa4d5752084a5ef0e0085a66" title="This state is assigned to processes that are permanently off the ready_queue and will never run again...">STATE_ZOMBIE</a>. </p>
<p>Upon calling this function, the calling process becomes a "zombie", a permanent and irrevocable state in which the process is never again eligible for CPU cycles. This function also removes the calling process from the ready_queue and initiates a context switch by calling <a class="el" href="kernel_8h.html#aaae42c37d7e61697646625aafaeae957" title="Implements a context switch in TOS, giving another process a chance to run. ">resign()</a> immediately afterward. Once a process calls <a class="el" href="kernel_8h.html#a8f2384e9e590e0ee81cc9818744b2144" title="Changes the state of the calling process to STATE_ZOMBIE. ">become_zombie()</a>, it will never again be any other state other than <a class="el" href="kernel_8h.html#a8e13ad68fa4d5752084a5ef0e0085a66" title="This state is assigned to processes that are permanently off the ready_queue and will never run again...">STATE_ZOMBIE</a> and will never run again. The "zombie" state is useful for identifying those processes that will never be active or run again (as opposed to processes that are in a blocked state, which can be restored to <a class="el" href="kernel_8h.html#aa74af0876332d1a6258cff9745a1bd53" title="This state is assigned to processes that are eligible to run and are ready to use CPU cycles...">STATE_READY</a> at some future time). </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#ab4e099987c910c0a74ddb26ffe7b1774" title="An array of pointers to PCBs for those processes that are ready to use CPU cycles. ">ready_queue</a>, <a class="el" href="kernel_8h.html#a1c9e82f9b4c35add01dad50fdf183e9a" title="Removes a process from the ready queue. ">remove_ready_queue()</a>, <a class="el" href="kernel_8h.html#aaae42c37d7e61697646625aafaeae957" title="Implements a context switch in TOS, giving another process a chance to run. ">resign()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aac67275347b6021ea8bd6b9db6a3a512"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clear_window </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structWINDOW.html">WINDOW</a> *&#160;</td>
          <td class="paramname"><em>wnd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the contents of the window. </p>
<p>The window content is erased and the cursor is placed at the top left corner of the empty window. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wnd</td><td>Pointer to the <a class="el" href="structWINDOW.html" title="Contains the properties of a specific window. ">WINDOW</a> struct that specifies the window. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structWINDOW.html" title="Contains the properties of a specific window. ">WINDOW</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad2213e4e559d438d23552fbd3c2a107a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void close_port </td>
          <td>(</td>
          <td class="paramtype">PORT&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes a port. </p>
<p>Closes the <a class="el" href="struct__PORT__DEF.html">PORT</a> indicated by the parameter port. Messages can still be sent to a closed port, but they will not be delivered to the receiver. Instead, they are queued for delivery at some later time, after the port has been re-opened. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a3f22fb991371149226f31ddf10f47795" title="Opens a port. ">open_port()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a191b96a6ebaa20de1b58bcd3956bbcd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PORT create_new_port </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_8h.html#a831d87f38811800ce0698bbe85e6b386">PROCESS</a>&#160;</td>
          <td class="paramname"><em>proc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new port for the process indicated by the parameter proc. </p>
<p>This function creates and returns a new port for the <a class="el" href="struct__PCB.html">PROCESS</a> indicated by proc. The port is initially open. Note that while a process can own multiple ports, each port can be owned by exactly one process. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="struct__PORT__DEF.html">PORT</a>, <a class="el" href="struct__PCB.html">PCB</a>, <a class="el" href="kernel_8h.html#a087ab3f9b5dff3f23f91a1b6e66e5072" title="The actively-running process. ">active_proc</a>, <a class="el" href="kernel_8h.html#ae9d255ea2fe47c5ee2c757bf6416227d" title="Creates a new port for the calling process. ">create_port()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae9d255ea2fe47c5ee2c757bf6416227d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PORT create_port </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new port for the calling process. </p>
<p>This function creates and returns a new port for the running process active_proc. The port is initially open. Note that while a process can own multiple ports, each port can be owned by exactly one process. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="struct__PORT__DEF.html">PORT</a>, <a class="el" href="struct__PCB.html">PCB</a>, <a class="el" href="kernel_8h.html#a087ab3f9b5dff3f23f91a1b6e66e5072" title="The actively-running process. ">active_proc</a>, <a class="el" href="kernel_8h.html#a191b96a6ebaa20de1b58bcd3956bbcd8" title="Creates a new port for the process indicated by the parameter proc. ">create_new_port()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae982573084c63244f2b0c4f8acb043f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PORT create_process </td>
          <td>(</td>
          <td class="paramtype">void(*)(<a class="el" href="kernel_8h.html#a831d87f38811800ce0698bbe85e6b386">PROCESS</a>, <a class="el" href="kernel_8h.html#a83f26503eb4a201692c1e8d8bb2e168d">PARAM</a>)&#160;</td>
          <td class="paramname"><em>new_proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kernel_8h.html#a83f26503eb4a201692c1e8d8bb2e168d">PARAM</a>&#160;</td>
          <td class="paramname"><em>param</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>proc_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new TOS process and returns the <a class="el" href="struct__PORT__DEF.html">PORT</a> owned by the new process (or, before ports are covered, returns a NULL pointer). </p>
<p>When the running process calls this function, a new TOS process is created through the following steps:<br />
(1) The next available PCB entry in the global pcb array is allocated;<br />
 (2) the elements of this PCB entry are initialized (see the lecture slide on create_process for a full description);<br />
 (3) an available 16kb stack frame for this process is allocated;<br />
 (4) the newly-allocated stack frame is initialized (see the lecture slide describing how this function populates the stack);<br />
(5) the stack pointer is saved to the PCB.esp field for this PCB entry;<br />
(6) the new process is added to the ready queue (but note that <a class="el" href="kernel_8h.html#aaae42c37d7e61697646625aafaeae957" title="Implements a context switch in TOS, giving another process a chance to run. ">resign()</a> is not called, and that the new process does not start running immediately);<br />
(7) return either a null pointer (before the class covers ports) or the <a class="el" href="struct__PORT__DEF.html">PORT</a> of the new process.<br />
<br />
Note that the implementation of <a class="el" href="kernel_8h.html#ae982573084c63244f2b0c4f8acb043f7" title="Creates a new TOS process and returns the PORT owned by the new process (or, before ports are covered...">create_process()</a> will change slightly once interrupts are introduced, later in the course. See the "Preemptive Multitasking" slide deck for more information at the appropriate time in the course. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">new_proc</td><td>Function pointer to a C function that takes a PROCESS and a PARAM as input arguments and returns void. This function pointer new_proc serves as the entry point for the newly-created TOS process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prio</td><td>Integer specifying the priority of this new process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">param</td><td>A parameter to be passed in to the new process and placed on the new process's stack frame </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>Pointer to the first element of a character array that indicates the name of the new process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct__PORT__DEF.html">PORT</a> The port owned by the newly-created process. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct__PORT__DEF.html">PORT</a>, <a class="el" href="kernel_8h.html#a83f26503eb4a201692c1e8d8bb2e168d" title="A typedef that creates the alternative name PARAM for an unsigned integer type. ">PARAM</a>, <a class="el" href="kernel_8h.html#a831d87f38811800ce0698bbe85e6b386" title="Typedef for a pointer to a PCB struct. ">PROCESS</a>, <a class="el" href="struct__PCB.html">PCB</a>, <a class="el" href="kernel_8h.html#a5e64f2ad93cc9de92000f884e6e0a8a9" title="An array of twenty PCB structs. ">pcb</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3b26baa874c4de9d0db0020a495f307e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kernel_8h.html#a831d87f38811800ce0698bbe85e6b386">PROCESS</a> dispatcher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects and returns the next process to run. </p>
<p>Only processes that are on the ready queue are eligible to be selected. TOS uses priority-based round robin scheduling: higher-priority processes are chosen to run before lower-priority processes. Within the same priority level, a round-robin scheduling approach is used: the next process on the ready queue at that priority level is chosen (or, if the process is the only one at its priority level, it will be chosen). It is assumed that there is always at least one process on the ready queue: to guarantee that this assumption holds, a null process of priority 0 is always on the ready queue and never becomes blocked under any circumstances. See the lecture slide called "Scheduling" for more information. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a087ab3f9b5dff3f23f91a1b6e66e5072" title="The actively-running process. ">active_proc</a>, <a class="el" href="kernel_8h.html#ab4e099987c910c0a74ddb26ffe7b1774" title="An array of pointers to PCBs for those processes that are ready to use CPU cycles. ">ready_queue</a>, <a class="el" href="kernel_8h.html#a11dd35e7b561c664f6b9deca1c30444a" title="Creates the null process. ">init_null_process()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afbedc913aa4651b3c3b4b3aecd9b4711"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Frees a previously-allocated region of memory. </p>
<p>The parameter ptr must have been previously returned by <a class="el" href="kernel_8h.html#a7ac38fce3243a7dcf448301ee9ffd392" title="Dynamically allocates a continuous region of memory. ">malloc()</a>. This function should be called only once for a given pointer, and memory pointed to by ptr should not be accessed anymore after a call to <a class="el" href="kernel_8h.html#afbedc913aa4651b3c3b4b3aecd9b4711" title="Frees a previously-allocated region of memory. ">free()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>A void pointer to the memory region previously allocated by a call to <a class="el" href="kernel_8h.html#a7ac38fce3243a7dcf448301ee9ffd392" title="Dynamically allocates a continuous region of memory. ">malloc()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a7ac38fce3243a7dcf448301ee9ffd392" title="Dynamically allocates a continuous region of memory. ">malloc()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a667529bb896d3107cb5d62f608dceaa5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_com </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the COM subsystem of TOS. </p>
<p>This function initializes the UART ("Universal Asynchronous Receiver/Transmitter") that implements the RS232 protocol for serial line communication used by TOS. This function also creates the COM process by calling <a class="el" href="kernel_8h.html#ae982573084c63244f2b0c4f8acb043f7" title="Creates a new TOS process and returns the PORT owned by the new process (or, before ports are covered...">create_process()</a>. The global variable <a class="el" href="com_8c.html#a3235fc563e60489c99c3a3959ead5f24">com_port</a> is set to point to the <a class="el" href="struct__PORT__DEF.html">PORT</a> (not to be confused with an I/O port) that is owned by the COM process. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="struct__COM__Message.html">COM_Message</a>, <a class="el" href="kernel_8h.html#a3235fc563e60489c99c3a3959ead5f24" title="A PORT owned by the COM process to receive messages from user processes. ">com_port</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6b9a52d032bce03b717484ec230ece45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_dispatcher </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the global variables associated with the ready queue. </p>
<p>This function is called by <a class="el" href="main_8c.html#a017bb803a0e9e7782bff19e961ec700d" title="The entry point of TOS unless running in test mode. ">kernel_main()</a> to prepare the ready queue and associated global variables. In one possible implementation, each entry of the ready queue is initialized with a null pointer; and the global variable ready_procs in <a class="el" href="dispatch_8c.html" title="Task scheduling. ">dispatch.c</a> is set to zero; and the calling process (the boot process) is added to the ready queue. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#ab4e099987c910c0a74ddb26ffe7b1774" title="An array of pointers to PCBs for those processes that are ready to use CPU cycles. ">ready_queue</a>, <a class="el" href="struct__PCB.html">PCB</a>, <a class="el" href="kernel_8h.html#a4aeea7e226886cd1f41c19e26e94884e" title="Adds a process to the ready queue. ">add_ready_queue()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="add2a7dc4c8b814a7e11ffc87780df7d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_idt_entry </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intr_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>isr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the <a class="el" href="structIDT.html" title="Holds the data fields associated with an x86 interrupt. ">IDT</a> entry for a single interrupt. </p>
<p>This function initializes the entry in the <a class="el" href="structIDT.html" title="Holds the data fields associated with an x86 interrupt. ">IDT</a> for the interrupt specified by the integer intr_no. The offset of the <a class="el" href="structIDT.html" title="Holds the data fields associated with an x86 interrupt. ">IDT</a> entry is populated with the value of the function pointer to the ISR. See the "Interrupts" lecture slides for more information about the <a class="el" href="structIDT.html" title="Holds the data fields associated with an x86 interrupt. ">IDT</a> data structures. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">intr_no</td><td>Integer number of the interrupt that this <a class="el" href="structIDT.html" title="Holds the data fields associated with an x86 interrupt. ">IDT</a> entry describes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">isr</td><td>Function pointer to a C function that takes no arguments and returns void; this function pointer is the entry point for the interrupt service routine for the interrupt numbered intr_no. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a88ada49c1954d38252049786595d9a5f" title="Initializes the interrupt subsystem of TOS. ">init_interrupts()</a>, <a class="el" href="structIDT.html" title="Holds the data fields associated with an x86 interrupt. ">IDT</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a88ada49c1954d38252049786595d9a5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_interrupts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the interrupt subsystem of TOS. </p>
<p>This function initializes each of the 256 entries in the interrupt descriptor table (by calling <a class="el" href="kernel_8h.html#add2a7dc4c8b814a7e11ffc87780df7d7" title="Initializes the IDT entry for a single interrupt. ">init_idt_entry()</a> 256 times, once for each interrupt). See the "Interrupts" lecture slides for more information on the <a class="el" href="structIDT.html" title="Holds the data fields associated with an x86 interrupt. ">IDT</a> entries and the different types of interrupts. This function also sets the global variable interrupts_initialized to true, and enables interrupts by executing the assembly instruction "sti". Note: in TOS, the three types of interrupts that can be handled are the keyboard interrupt, timer interrupt, and COM1 interrupt. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#add2a7dc4c8b814a7e11ffc87780df7d7" title="Initializes the IDT entry for a single interrupt. ">init_idt_entry()</a>, <a class="el" href="structIDT.html" title="Holds the data fields associated with an x86 interrupt. ">IDT</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7ab33da3342afdd7d505cae618be9d5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_ipc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the global variables associated with inter-process communication. </p>
<p>This function is called by <a class="el" href="main_8c.html#a017bb803a0e9e7782bff19e961ec700d" title="The entry point of TOS unless running in test mode. ">kernel_main()</a> to initialize the entries of an array of pointers to <a class="el" href="struct__PORT__DEF.html">PORT</a> data structures, and to assign the array to a global variable. Among other things, each element of the array contains a pointer to the next element of the array and a field indicating whether the array entry is being used by a process. See the "IPC" slide deck for more information about the setup of inter-process communication. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="struct__PORT__DEF.html">PORT</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a48cd3acd7319667c875c62b570b9db49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_keyb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the keyboard process. </p>
<p>This process creates the keyboard process and assigns the <a class="el" href="struct__PORT__DEF.html">PORT</a> returned by the call to <a class="el" href="kernel_8h.html#ae982573084c63244f2b0c4f8acb043f7" title="Creates a new TOS process and returns the PORT owned by the new process (or, before ports are covered...">create_process()</a> to the global variable keyb_port. Note: this process must be called after the initialization of the Window Manager via <a class="el" href="kernel_8h.html#adee9719f3126c238ba343ac0d6b40d6a" title="Initializes the Window Manager service. ">init_wm()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a5703cd456b7a86eac9a03b4dce660b34" title="Queries the keyboard process for the next keystroke. ">keyb_get_keystroke()</a>, <a class="el" href="kernel_8h.html#afc32d8217e2da0da36dc851cbc97cdac" title="The PORT owned by the keyboard process. ">keyb_port</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a11dd35e7b561c664f6b9deca1c30444a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_null_process </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the null process. </p>
<p>As TOS starts to run, this function is called in order to create a "null process" at priority level 0 which will always be on the ready queue. No other process will ever have priority level 0, so that <a class="el" href="kernel_8h.html#a3b26baa874c4de9d0db0020a495f307e" title="Selects and returns the next process to run. ">dispatcher()</a> will never choose the null process unless it is the only process on the ready queue (i.e., all other processes are <a class="el" href="kernel_8h.html#a8e13ad68fa4d5752084a5ef0e0085a66" title="This state is assigned to processes that are permanently off the ready_queue and will never run again...">STATE_ZOMBIE</a> or in one of the blocked states). The null process exists to guarantee that there is always at least one process on the ready queue. The null process should never become any state other than <a class="el" href="kernel_8h.html#aa74af0876332d1a6258cff9745a1bd53" title="This state is assigned to processes that are eligible to run and are ready to use CPU cycles...">STATE_READY</a>. The C function that defines the null process is simply an infinite while loop, so that like all other TOS processes, the null process never returns to its caller in the traditional sense. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#ae982573084c63244f2b0c4f8acb043f7" title="Creates a new TOS process and returns the PORT owned by the new process (or, before ports are covered...">create_process()</a>, <a class="el" href="kernel_8h.html#ab4e099987c910c0a74ddb26ffe7b1774" title="An array of pointers to PCBs for those processes that are ready to use CPU cycles. ">ready_queue</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab25d44702b6e10e723714c368c4a7520"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_process </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the global variables associated with TOS process creation. </p>
<p>This function clears all the entries in the <a class="el" href="process_8c.html#aa13757c49c1256b766ebc3d259ed94a3">pcb</a> array; prepares the doubly-linked list of entries so that each array entry contains the address of the next available PCB slot; prepares the pcb entry for the boot process, and sets the global variable active_proc (used throughout TOS) to the first entry of the <a class="el" href="process_8c.html#aa13757c49c1256b766ebc3d259ed94a3">pcb</a> array. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a5e64f2ad93cc9de92000f884e6e0a8a9" title="An array of twenty PCB structs. ">pcb</a>, <a class="el" href="struct__PCB.html">PCB</a>, <a class="el" href="kernel_8h.html#a831d87f38811800ce0698bbe85e6b386" title="Typedef for a pointer to a PCB struct. ">PROCESS</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a38016ab7b2931bcb950e0c6f3ba3f342"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_timer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the timer process. </p>
<p>This function creates the timer process and the port, called <a class="el" href="kernel_8h.html#a7271a38be80889290a3b624f3d6bad83" title="The PORT owned by the timer process. ">timer_port</a>, which is owned by the timer process. This function also calls <a class="el" href="kernel_8h.html#aaae42c37d7e61697646625aafaeae957" title="Implements a context switch in TOS, giving another process a chance to run. ">resign()</a> to initiate a context switch. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="struct__Timer__Message.html">Timer_Message</a>, <a class="el" href="kernel_8h.html#a2d8ece954c7a70eb04493321c6e46f3c" title="Puts the calling process to sleep (off the ready queue) for a specified number of timer ticks...">sleep()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab4d3133069013495ad0f53636b0d638d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_train </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a train process in TOS. </p>
<p>This function will be implemented as a part of the final project. </p>

</div>
</div>
<a class="anchor" id="adee9719f3126c238ba343ac0d6b40d6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void init_wm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the Window Manager service. </p>
<p>This function is called once from <a class="el" href="main_8c.html#a017bb803a0e9e7782bff19e961ec700d" title="The entry point of TOS unless running in test mode. ">kernel_main()</a> and creates the Window Manager process. </p>

</div>
</div>
<a class="anchor" id="a60511a9660702b537d639a4096cd9988"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char inportb </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a byte from the I/O port designated by the argument port. </p>
<p>The port should not be confused with the ports used for inter-process communication. COM1 can be accessed via I/O ports 0x3F8 through 0x3FF, with the base address 0x3F8 defined as <a class="el" href="kernel_8h.html#a8982f081d8608e775b0739cde65373d5" title="The base address of the I/O ports associated with COM1. ">COM1_PORT</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>The I/O port from which the byte is to be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a5c698260d261a6984816b27db7a3398e" title="Writes the byte value to the I/O port designated by the argument port. ">outportb()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af222ffdb13057ff818cc0422e6499929"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_memcmp </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>b1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>b2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two memory areas of specified length. </p>
<p>Compares the first len bytes of memory regions b1 and b2. If all the bytes in the two regions are matching, the function returns 0. The function returns an integer less than zero or more than zero if the first len bytes of b1 are found to be less than, or greater than, the first len bytes of b2 respectively. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b1</td><td>A void pointer to a first memory region. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b2</td><td>A void pointer to a second memory region. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of bytes of each memory region to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An integer indicating the results of the comparison. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#aa975844c3752be598cbe656c3be7c79d" title="Copies a region of memory of a specified length. ">k_memcpy()</a>, <a class="el" href="kernel_8h.html#a61623fea0b3d96da57e082b7d9c032ed" title="Fills a memory region with a constant byte. ">k_memset()</a>, <a class="el" href="kernel_8h.html#ad677fd23d0774acf0b858096f14c54eb" title="Calculates the length of a string. ">k_strlen()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa975844c3752be598cbe656c3be7c79d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* k_memcpy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies a region of memory of a specified length. </p>
<p>Copies len bytes from memory region src to memory region dst. The source and destination memory regions must not overlap. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>A void pointer to the source memory region. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Integer number of bytes to copy. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>A void pointer to the destination memory region. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#af222ffdb13057ff818cc0422e6499929" title="Compares two memory areas of specified length. ">k_memcmp()</a>, <a class="el" href="kernel_8h.html#a61623fea0b3d96da57e082b7d9c032ed" title="Fills a memory region with a constant byte. ">k_memset()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a61623fea0b3d96da57e082b7d9c032ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void k_memset </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>fill</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills a memory region with a constant byte. </p>
<p>Fills the first len bytes of the memory region pointed to by b with the character fill. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fill</td><td>The character with which to fill the first len bytes of the memory region. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>The number of bytes of the memory region to be filled with the input character fill. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>A void pointer to the memory region in which the first len bytes are filled with the character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#aa975844c3752be598cbe656c3be7c79d" title="Copies a region of memory of a specified length. ">k_memcpy()</a>, <a class="el" href="kernel_8h.html#af222ffdb13057ff818cc0422e6499929" title="Compares two memory areas of specified length. ">k_memcmp()</a>, <a class="el" href="kernel_8h.html#ad677fd23d0774acf0b858096f14c54eb" title="Calculates the length of a string. ">k_strlen()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad677fd23d0774acf0b858096f14c54eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int k_strlen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the length of a string. </p>
<p>Calculates the length of the string pointed to by str, excluding the null-terminating byte ('\0'). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Pointer to an array of character constants. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of characters in the string pointed to by str. </dd></dl>

</div>
</div>
<a class="anchor" id="a5703cd456b7a86eac9a03b4dce660b34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char keyb_get_keystroke </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>window_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kernel_8h.html#a050c65e107f0c828f856a231f4b4e788">BOOL</a>&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queries the keyboard process for the next keystroke. </p>
<p>This function enables a user process to request the next available keystroke to a specific window. The keystroke is returned only when the window identified by window_id has the input focus. If the argument block is set to TRUE, then the calling process will be blocked until a keystroke is available; if set to FALSE, then this function returns zero to the caller immediately so that it is not blocked. See the slides on the Window Manager and TOS++ for more information. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">window_id</td><td>The integer identifier of an existing window that was previously created via <a class="el" href="kernel_8h.html#a8ee6330fe2c39feda7b1a2e909452db5" title="Creates a new window via the Window Manager service. ">wm_create()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Boolean indicator of whether the caller should be blocked until a keystroke is received. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a8ee6330fe2c39feda7b1a2e909452db5" title="Creates a new window via the Window Manager service. ">wm_create()</a>, <a class="el" href="kernel_8h.html#afc32d8217e2da0da36dc851cbc97cdac" title="The PORT owned by the keyboard process. ">keyb_port</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a199a1f701f4cc4fd1c3ff7903a102d7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kprintf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints content to the <a class="el" href="kernel_8h.html#aeb93d089146101ad08f141c0fc2c6b15" title="Pointer to a WINDOW struct for a window that covers the entire screen. ">kernel_window</a> in accordance with the specified format or conversion. </p>
<p><a class="el" href="kernel_8h.html#a199a1f701f4cc4fd1c3ff7903a102d7a" title="Prints content to the kernel_window in accordance with the specified format or conversion. ">kprintf()</a> and <a class="el" href="kernel_8h.html#ae02cb6e6121bb801f5a6411769adc6ee" title="Prints content to a window in accordance with the specified format or conversion. ...">wprintf()</a> are the TOS version of the C function printf(), allowing formatted printing or conversion and variable argument lists. Example usages of <a class="el" href="kernel_8h.html#a199a1f701f4cc4fd1c3ff7903a102d7a" title="Prints content to the kernel_window in accordance with the specified format or conversion. ">kprintf()</a> can be found in the lectures slides. Supported printf features and conversions include d (decimal), u (unsigned), x (hexadecimal), X (hex with capital letters), o (octal), c (character), s (string), %m.n (field width and precision), %%-m.n (left adjustment), %0m.n (zero-padding), %%*.* (width and precision taken from arguments), and b (binary conversion). The function <a class="el" href="kernel_8h.html#a88ae83b120b2747f3791ef7bc743de62" title="Implements formatted-print features of the wprintf() and kprintf() functions. ">vsprintf()</a> parses the format specifier and optional arguments and creates a character buffer containing the output string correctly formatted in accordance with how printf() behaves. This function is identical to calling wprintf(kernel_window, const char* fmt). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>Pointer to the string to be printed and which may include format tags. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Refers to zero or more optional arguments that specify the format(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#ae02cb6e6121bb801f5a6411769adc6ee" title="Prints content to a window in accordance with the specified format or conversion. ...">wprintf()</a>, <a class="el" href="kernel_8h.html#a88ae83b120b2747f3791ef7bc743de62" title="Implements formatted-print features of the wprintf() and kprintf() functions. ">vsprintf()</a>, <a class="el" href="kernel_8h.html#ae430920aa5940d9c9e34a5ec6e5c1ed8" title="Displays a string starting at the cursor location, and advances the cursor appropriately after the en...">output_string()</a>, <a class="el" href="kernel_8h.html#aeb93d089146101ad08f141c0fc2c6b15" title="Pointer to a WINDOW struct for a window that covers the entire screen. ">kernel_window</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7ac38fce3243a7dcf448301ee9ffd392"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* malloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_8h.html#a7619b847aeded8a6d14cbfa212b2cdfb">size_t</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dynamically allocates a continuous region of memory. </p>
<p>TOS supports high memory in the region from 1 MB to 8 MB, which is managed by <a class="el" href="kernel_8h.html#a7ac38fce3243a7dcf448301ee9ffd392" title="Dynamically allocates a continuous region of memory. ">malloc()</a>. A caller of <a class="el" href="kernel_8h.html#a7ac38fce3243a7dcf448301ee9ffd392" title="Dynamically allocates a continuous region of memory. ">malloc()</a> is allocated a continuous region of high memory. Malloc keeps track of fragmentation in high memory using its own data structure and finds a sufficiently-sized region of memory for the caller. The allocated memory is not initialized (e.g., zeroed out) in any way. If no sufficiently-sized region of memory is available, <a class="el" href="kernel_8h.html#a7ac38fce3243a7dcf448301ee9ffd392" title="Dynamically allocates a continuous region of memory. ">malloc()</a> stops TOS with a failed assertion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size of the requested memory region. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A void pointer to the allocated memory region. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#afbedc913aa4651b3c3b4b3aecd9b4711" title="Frees a previously-allocated region of memory. ">free()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aacc4f7df1c840c0e6f109dfde5ff934f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void message </td>
          <td>(</td>
          <td class="paramtype">PORT&#160;</td>
          <td class="paramname"><em>dest_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a message to the <a class="el" href="struct__PORT__DEF.html">PORT</a> of a receiver process, from which no reply is expected. </p>
<p>This function sends a synchronous message to the destination <a class="el" href="struct__PORT__DEF.html">PORT</a> indicated by the parameter dest_port. The void pointer data is the content of the message. If the receiver process has not yet called <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a>, the sender becomes <a class="el" href="kernel_8h.html#a16679ae7e3517177c16893143870a20f" title="This state is assigned to a process that has called message(), and the receiver process has not yet c...">STATE_MESSAGE_BLOCKED</a> until the receiver calls <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a>, after which time the sender is put back on the ready queue. If the sender becomes blocked, it is placed on the send-blocked list of the receiver, then goes off the ready queue and calls <a class="el" href="kernel_8h.html#aaae42c37d7e61697646625aafaeae957" title="Implements a context switch in TOS, giving another process a chance to run. ">resign()</a>. If the receiver process had already called <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a>, then the message can be delivered immediately and the sender does not become blocked. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest_port</td><td>A <a class="el" href="struct__PORT__DEF.html">PORT</a> owned by the receiver process, which must be open if the message is to be deliverable. See the slides on inter-process communication for more details. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>A void pointer to the data contained in the message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct__PORT__DEF.html">PORT</a>, <a class="el" href="kernel_8h.html#a70e779a204bd7960376d8f122d5afd5a" title="Sends a message to the PORT of a receiver process, and a reply to the message is expected. ">send()</a>, <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a>, <a class="el" href="kernel_8h.html#afae559b6ee61d6e596c651dde6028582" title="Replies to a message. ">reply()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa6dcfbefcba8307a0582eb19f633778a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void move_cursor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structWINDOW.html">WINDOW</a> *&#160;</td>
          <td class="paramname"><em>wnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places the cursor at a specific position. </p>
<p>The position of the cursor is set to be (x,y) relative to the upper left corner of the window. The position must be within the boundaries of the window. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wnd</td><td>Pointer to the <a class="el" href="structWINDOW.html" title="Contains the properties of a specific window. ">WINDOW</a> struct that specifies the window. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>Integer x-coordinate within the window where the cursor will be placed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>Integer y-coordinate within the window where the cursor will be placed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#ab406d8dcb6b139a7d87d4feae5e66895" title="Removes the cursor from a window. ">remove_cursor()</a>, <a class="el" href="structWINDOW.html" title="Contains the properties of a specific window. ">WINDOW</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3f22fb991371149226f31ddf10f47795"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void open_port </td>
          <td>(</td>
          <td class="paramtype">PORT&#160;</td>
          <td class="paramname"><em>port</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opens a port. </p>
<p>Opens the <a class="el" href="struct__PORT__DEF.html">PORT</a> indicated by the parameter port. Only messages that are in an open port can be delivered to the receiver. (Messages can still be sent to a closed port, but they will not be delivered to the receiver; instead, the messages are queued for later delivery.) </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#ad2213e4e559d438d23552fbd3c2a107a" title="Closes a port. ">close_port()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5c698260d261a6984816b27db7a3398e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void outportb </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the byte value to the I/O port designated by the argument port. </p>
<p>The port should not be confused with the ports used for inter-process communication. COM1 can be accessed via I/O ports 0x3F8 through 0x3FF, with the base address 0x3F8 defined as <a class="el" href="kernel_8h.html#a8982f081d8608e775b0739cde65373d5" title="The base address of the I/O ports associated with COM1. ">COM1_PORT</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">port</td><td>The I/O port to which the byte is to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The byte (as an unsigned character) to write to the I/O port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a60511a9660702b537d639a4096cd9988" title="Reads a byte from the I/O port designated by the argument port. ">inportb()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a08f7518813d0820b8ec1c1392de01954"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void output_char </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structWINDOW.html">WINDOW</a> *&#160;</td>
          <td class="paramname"><em>wnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays a character at the cursor location, and advances the cursor appropriately. </p>
<p>The indicated character is displayed at the cursor location, and the cursor is advanced to the next location appropriately in the same manner as within a shell. If necessary, the content of the window scrolls upward accordingly, also in the same manner as a shell. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wnd</td><td>Pointer to the <a class="el" href="structWINDOW.html" title="Contains the properties of a specific window. ">WINDOW</a> struct that specifies the window. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>The character to be displayed at the current cursor location. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#ae430920aa5940d9c9e34a5ec6e5c1ed8" title="Displays a string starting at the cursor location, and advances the cursor appropriately after the en...">output_string()</a>, <a class="el" href="structWINDOW.html" title="Contains the properties of a specific window. ">WINDOW</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae430920aa5940d9c9e34a5ec6e5c1ed8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void output_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structWINDOW.html">WINDOW</a> *&#160;</td>
          <td class="paramname"><em>wnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays a string starting at the cursor location, and advances the cursor appropriately after the end of the string. </p>
<p>The string (i.e., null-terminated array of constant characters) is displayed at the cursor location, and the cursor is advanced to the next location after the string appropriately in the same manner as within a shell. If necessary, the content of the window scrolls upward accordingly, also in the same manner as a shell. The implementation of this function calls <a class="el" href="kernel_8h.html#a08f7518813d0820b8ec1c1392de01954" title="Displays a character at the cursor location, and advances the cursor appropriately. ">output_char()</a> for each character in the string until the null terminator is reached. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wnd</td><td>Pointer to the <a class="el" href="structWINDOW.html" title="Contains the properties of a specific window. ">WINDOW</a> struct that specifies the window. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>Pointer to the first element in a string that is to be displayed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a08f7518813d0820b8ec1c1392de01954" title="Displays a character at the cursor location, and advances the cursor appropriately. ">output_char()</a>, <a class="el" href="structWINDOW.html" title="Contains the properties of a specific window. ">WINDOW</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4a8f6e8a276b0399a61460880d4aec4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kernel_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a> peek_b </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_8h.html#a5de4d864680acdb06c6f6fe11cc3d7d8">MEM_ADDR</a>&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads 1 byte from the specified memory address. </p>
<p>Reads and returns a <a class="el" href="kernel_8h.html#a4ae1dab0fb4b072a66584546209e7d58" title="Typedef for a single-byte data type. ">BYTE</a> from the memory address addr. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The memory address from which the 1-byte <a class="el" href="kernel_8h.html#a4ae1dab0fb4b072a66584546209e7d58" title="Typedef for a single-byte data type. ">BYTE</a> value is to be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="kernel_8h.html#a4ae1dab0fb4b072a66584546209e7d58" title="Typedef for a single-byte data type. ">BYTE</a> read from memory address addr. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a4a8f6e8a276b0399a61460880d4aec4f" title="Reads 1 byte from the specified memory address. ">peek_b()</a>, <a class="el" href="kernel_8h.html#a5de4d864680acdb06c6f6fe11cc3d7d8" title="Typedef for memory addresses within the main memory used by TOS. ">MEM_ADDR</a>, <a class="el" href="kernel_8h.html#a4ae1dab0fb4b072a66584546209e7d58" title="Typedef for a single-byte data type. ">BYTE</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0c1b9e00b9eafd82d022cb9ffd1dede4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kernel_8h.html#a434cb264031f389cbbf1844726748ebc">LONG</a> peek_l </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_8h.html#a5de4d864680acdb06c6f6fe11cc3d7d8">MEM_ADDR</a>&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads 4 bytes from the memory region starting at the specified memory address. </p>
<p>Reads and returns a <a class="el" href="kernel_8h.html#a434cb264031f389cbbf1844726748ebc" title="Typedef for an unsigned 4-byte data type. ">LONG</a> from the memory region starting at address addr. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The memory address from which the 4-byte <a class="el" href="kernel_8h.html#a434cb264031f389cbbf1844726748ebc" title="Typedef for an unsigned 4-byte data type. ">LONG</a> value is to be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="kernel_8h.html#a434cb264031f389cbbf1844726748ebc" title="Typedef for an unsigned 4-byte data type. ">LONG</a> read from the 4-byte memory region starting at memory address addr. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a0c1b9e00b9eafd82d022cb9ffd1dede4" title="Reads 4 bytes from the memory region starting at the specified memory address. ">peek_l()</a>, <a class="el" href="kernel_8h.html#a5de4d864680acdb06c6f6fe11cc3d7d8" title="Typedef for memory addresses within the main memory used by TOS. ">MEM_ADDR</a>, <a class="el" href="kernel_8h.html#a434cb264031f389cbbf1844726748ebc" title="Typedef for an unsigned 4-byte data type. ">LONG</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a89c825cbb154f72071dd38cdac44ff47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kernel_8h.html#a197942eefa7db30960ae396d68339b97">WORD</a> peek_w </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_8h.html#a5de4d864680acdb06c6f6fe11cc3d7d8">MEM_ADDR</a>&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads 2 bytes from the memory region starting at the specified memory address. </p>
<p>Reads and returns a <a class="el" href="kernel_8h.html#a197942eefa7db30960ae396d68339b97" title="Typedef for an unsigned 2-byte data type. ">WORD</a> from the memory region starting at address addr. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The memory address from which the 2-byte <a class="el" href="kernel_8h.html#a197942eefa7db30960ae396d68339b97" title="Typedef for an unsigned 2-byte data type. ">WORD</a> value is to be read. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="kernel_8h.html#a197942eefa7db30960ae396d68339b97" title="Typedef for an unsigned 2-byte data type. ">WORD</a> read from the 2-byte memory region starting at memory address addr. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a89c825cbb154f72071dd38cdac44ff47" title="Reads 2 bytes from the memory region starting at the specified memory address. ">peek_w()</a>, <a class="el" href="kernel_8h.html#a5de4d864680acdb06c6f6fe11cc3d7d8" title="Typedef for memory addresses within the main memory used by TOS. ">MEM_ADDR</a>, <a class="el" href="kernel_8h.html#a197942eefa7db30960ae396d68339b97" title="Typedef for an unsigned 2-byte data type. ">WORD</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a476fa8b29922cf1ab24cb49a57cd1667"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void poke_b </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_8h.html#a5de4d864680acdb06c6f6fe11cc3d7d8">MEM_ADDR</a>&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kernel_8h.html#a4ae1dab0fb4b072a66584546209e7d58">BYTE</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes 1 byte to memory at the specified memory address. </p>
<p>Writes value, a 1-byte item of data of type <a class="el" href="kernel_8h.html#a4ae1dab0fb4b072a66584546209e7d58" title="Typedef for a single-byte data type. ">BYTE</a>, to the memory address specified by addr. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>A <a class="el" href="kernel_8h.html#a5de4d864680acdb06c6f6fe11cc3d7d8" title="Typedef for memory addresses within the main memory used by TOS. ">MEM_ADDR</a>, or memory address, to which the <a class="el" href="kernel_8h.html#a4ae1dab0fb4b072a66584546209e7d58" title="Typedef for a single-byte data type. ">BYTE</a> is to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>A <a class="el" href="kernel_8h.html#a4ae1dab0fb4b072a66584546209e7d58" title="Typedef for a single-byte data type. ">BYTE</a> representing the value which is to be written to memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a4a8f6e8a276b0399a61460880d4aec4f" title="Reads 1 byte from the specified memory address. ">peek_b()</a>, <a class="el" href="kernel_8h.html#a4ae1dab0fb4b072a66584546209e7d58" title="Typedef for a single-byte data type. ">BYTE</a>, <a class="el" href="kernel_8h.html#a5de4d864680acdb06c6f6fe11cc3d7d8" title="Typedef for memory addresses within the main memory used by TOS. ">MEM_ADDR</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac89c27a57e5edfbab2cda145904016d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void poke_l </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_8h.html#a5de4d864680acdb06c6f6fe11cc3d7d8">MEM_ADDR</a>&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kernel_8h.html#a434cb264031f389cbbf1844726748ebc">LONG</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes 4 bytes to the memory region starting at the specified memory address. </p>
<p>Writes value, a 4-byte item of data of type <a class="el" href="kernel_8h.html#a434cb264031f389cbbf1844726748ebc" title="Typedef for an unsigned 4-byte data type. ">LONG</a>, to the 4-byte memory region starting at address addr. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>A <a class="el" href="kernel_8h.html#a5de4d864680acdb06c6f6fe11cc3d7d8" title="Typedef for memory addresses within the main memory used by TOS. ">MEM_ADDR</a>, or memory address, to which the <a class="el" href="kernel_8h.html#a434cb264031f389cbbf1844726748ebc" title="Typedef for an unsigned 4-byte data type. ">LONG</a> is to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>A <a class="el" href="kernel_8h.html#a434cb264031f389cbbf1844726748ebc" title="Typedef for an unsigned 4-byte data type. ">LONG</a> representing the value which is to be written to memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#ac89c27a57e5edfbab2cda145904016d1" title="Writes 4 bytes to the memory region starting at the specified memory address. ">poke_l()</a>, <a class="el" href="kernel_8h.html#a434cb264031f389cbbf1844726748ebc" title="Typedef for an unsigned 4-byte data type. ">LONG</a>, <a class="el" href="kernel_8h.html#a5de4d864680acdb06c6f6fe11cc3d7d8" title="Typedef for memory addresses within the main memory used by TOS. ">MEM_ADDR</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad3879aa37ac302cf88e706b93be197cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void poke_w </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_8h.html#a5de4d864680acdb06c6f6fe11cc3d7d8">MEM_ADDR</a>&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kernel_8h.html#a197942eefa7db30960ae396d68339b97">WORD</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes 2 bytes to the memory region starting at the specified memory address. </p>
<p>Writes value, a 2-byte item of data of type <a class="el" href="kernel_8h.html#a197942eefa7db30960ae396d68339b97" title="Typedef for an unsigned 2-byte data type. ">WORD</a>, to the 2-byte memory region starting at address addr. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>A <a class="el" href="kernel_8h.html#a5de4d864680acdb06c6f6fe11cc3d7d8" title="Typedef for memory addresses within the main memory used by TOS. ">MEM_ADDR</a>, or memory address, to which the <a class="el" href="kernel_8h.html#a197942eefa7db30960ae396d68339b97" title="Typedef for an unsigned 2-byte data type. ">WORD</a> is to be written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>A <a class="el" href="kernel_8h.html#a197942eefa7db30960ae396d68339b97" title="Typedef for an unsigned 2-byte data type. ">WORD</a> representing the value which is to be written to memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#ad3879aa37ac302cf88e706b93be197cb" title="Writes 2 bytes to the memory region starting at the specified memory address. ">poke_w()</a>, <a class="el" href="kernel_8h.html#a197942eefa7db30960ae396d68339b97" title="Typedef for an unsigned 2-byte data type. ">WORD</a>, <a class="el" href="kernel_8h.html#a5de4d864680acdb06c6f6fe11cc3d7d8" title="Typedef for memory addresses within the main memory used by TOS. ">MEM_ADDR</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae816c773af94e99847e12d847fe1b252"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_all_processes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structWINDOW.html">WINDOW</a> *&#160;</td>
          <td class="paramname"><em>wnd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the details of all existing TOS processes. </p>
<p>The name, state, and priority of each existing TOS process is printed, with a special character (e.g., an asterisk) indicating if the process is currently the running process. See the lecture slides on TOS processes for an example of how the output may look like. One possible implementation of this function calls <a class="el" href="kernel_8h.html#a0ba03cb110510187d40043ffd1352d57" title="Prints the details of the specified TOS process. ">print_process()</a> for each of the processes in the <a class="el" href="process_8c.html#aa13757c49c1256b766ebc3d259ed94a3">pcb</a> array. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wnd</td><td>Pointer to the <a class="el" href="structWINDOW.html" title="Contains the properties of a specific window. ">WINDOW</a> to which the process details should be printed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a0ba03cb110510187d40043ffd1352d57" title="Prints the details of the specified TOS process. ">print_process()</a>, <a class="el" href="kernel_8h.html#a5e64f2ad93cc9de92000f884e6e0a8a9" title="An array of twenty PCB structs. ">pcb</a>, <a class="el" href="struct__PCB.html">PCB</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0ba03cb110510187d40043ffd1352d57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_process </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structWINDOW.html">WINDOW</a> *&#160;</td>
          <td class="paramname"><em>wnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="kernel_8h.html#a831d87f38811800ce0698bbe85e6b386">PROCESS</a>&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the details of the specified TOS process. </p>
<p>The name, state, and priority of the TOS process is printed, with a special character (e.g., an asterisk) indicating if the process is currently the running process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wnd</td><td>Pointer to the <a class="el" href="structWINDOW.html" title="Contains the properties of a specific window. ">WINDOW</a> to which the process details should be printed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The process whose details should be printed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#ae816c773af94e99847e12d847fe1b252" title="Prints the details of all existing TOS processes. ">print_all_processes()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a57fe8a985abbaec28b7065d0ad3b3e80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* receive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_8h.html#a831d87f38811800ce0698bbe85e6b386">PROCESS</a> *&#160;</td>
          <td class="paramname"><em>sender</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Receives a message. </p>
<p>If there is a message pending for this process (i.e., one of the open ports owned by this process contains a message from a sender process), this function receives that message and reacts accordingly, depending on whether the sender used <a class="el" href="kernel_8h.html#a70e779a204bd7960376d8f122d5afd5a" title="Sends a message to the PORT of a receiver process, and a reply to the message is expected. ">send()</a> or <a class="el" href="kernel_8h.html#aacc4f7df1c840c0e6f109dfde5ff934f" title="Sends a message to the PORT of a receiver process, from which no reply is expected. ">message()</a>. If no message is pending for this process, or if the port is closed, the process becomes <a class="el" href="kernel_8h.html#ac08fbd3b65bb3ea13b91882b70606e0e" title="This state is assigned to a process that has called receive(), but there are no messages pending from...">STATE_RECEIVE_BLOCKED</a> and calls <a class="el" href="kernel_8h.html#aaae42c37d7e61697646625aafaeae957" title="Implements a context switch in TOS, giving another process a chance to run. ">resign()</a>. See the inter-process communication lecture slides for more details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">sender</td><td>A pointer which is modified by the <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a> function to point to the sender <a class="el" href="kernel_8h.html#a831d87f38811800ce0698bbe85e6b386">PROCESS</a> (as such, this is an output argument). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A void pointer passed by the sender process to the content of the message. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct__PORT__DEF.html">PORT</a>, <a class="el" href="kernel_8h.html#a70e779a204bd7960376d8f122d5afd5a" title="Sends a message to the PORT of a receiver process, and a reply to the message is expected. ">send()</a>, <a class="el" href="kernel_8h.html#aacc4f7df1c840c0e6f109dfde5ff934f" title="Sends a message to the PORT of a receiver process, from which no reply is expected. ">message()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab406d8dcb6b139a7d87d4feae5e66895"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remove_cursor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structWINDOW.html">WINDOW</a> *&#160;</td>
          <td class="paramname"><em>wnd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the cursor from a window. </p>
<p>Removes the cursor by displaying a blank character at the cursor location specified by cursor_x and cursor_y of this <a class="el" href="structWINDOW.html" title="Contains the properties of a specific window. ">WINDOW</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wnd</td><td>Pointer to the <a class="el" href="structWINDOW.html" title="Contains the properties of a specific window. ">WINDOW</a> struct that specifies the window. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#aa6dcfbefcba8307a0582eb19f633778a" title="Places the cursor at a specific position. ">move_cursor()</a>, <a class="el" href="structWINDOW.html" title="Contains the properties of a specific window. ">WINDOW</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1c9e82f9b4c35add01dad50fdf183e9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void remove_ready_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_8h.html#a831d87f38811800ce0698bbe85e6b386">PROCESS</a>&#160;</td>
          <td class="paramname"><em>proc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes a process from the ready queue. </p>
<p>When a process's state becomes anything other than <a class="el" href="kernel_8h.html#aa74af0876332d1a6258cff9745a1bd53" title="This state is assigned to processes that are eligible to run and are ready to use CPU cycles...">STATE_READY</a> (for example, if a state becomes blocked or a zombie), it must be removed from the ready queue because it has become ineligible for CPU cycles. This function removes that process from the ready queue and modifies the ready queue's doubly-linked list at the appropriate prioirity level so as to restore the doubly-linked list after removing the process from it. For example, if priority 5 of the ready queue has the doubly-linked list A-B-C, and remove_ready_queue(B) is called, this function updates the doubly-linked list to A-C. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">proc</td><td>Process to be removed from the ready queue </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#ab4e099987c910c0a74ddb26ffe7b1774" title="An array of pointers to PCBs for those processes that are ready to use CPU cycles. ">ready_queue</a>, <a class="el" href="kernel_8h.html#a4aeea7e226886cd1f41c19e26e94884e" title="Adds a process to the ready queue. ">add_ready_queue</a>, <a class="el" href="kernel_8h.html#a3b26baa874c4de9d0db0020a495f307e" title="Selects and returns the next process to run. ">dispatcher()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="afae559b6ee61d6e596c651dde6028582"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void reply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="kernel_8h.html#a831d87f38811800ce0698bbe85e6b386">PROCESS</a>&#160;</td>
          <td class="paramname"><em>sender</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replies to a message. </p>
<p>This function causes the receiver process to reply to the sender process. The receiver must have previously received a message from the sender and the sender must be <a class="el" href="kernel_8h.html#a600b8498ae32f931e812309e3ea0b715" title="This state is assigned to a sending process in the situation where the process has called send() and ...">STATE_REPLY_BLOCKED</a>. The receiver puts the sender back on the ready queue and then calls <a class="el" href="kernel_8h.html#aaae42c37d7e61697646625aafaeae957" title="Implements a context switch in TOS, giving another process a chance to run. ">resign()</a> to give another process a chance to run. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sender</td><td>The <a class="el" href="kernel_8h.html#a831d87f38811800ce0698bbe85e6b386">PROCESS</a> which sent the message and is awaiting the reply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a70e779a204bd7960376d8f122d5afd5a" title="Sends a message to the PORT of a receiver process, and a reply to the message is expected. ">send()</a>, <a class="el" href="kernel_8h.html#aacc4f7df1c840c0e6f109dfde5ff934f" title="Sends a message to the PORT of a receiver process, from which no reply is expected. ">message()</a>, <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aaae42c37d7e61697646625aafaeae957"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void resign </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements a context switch in TOS, giving another process a chance to run. </p>
<p>This function does the following steps: (1) it saves the context of the current process pointed to by the global variable active_proc; (2) it calls <a class="el" href="kernel_8h.html#a3b26baa874c4de9d0db0020a495f307e" title="Selects and returns the next process to run. ">dispatcher()</a> and assigns the process returned by <a class="el" href="kernel_8h.html#a3b26baa874c4de9d0db0020a495f307e" title="Selects and returns the next process to run. ">dispatcher()</a> to active_proc; (3) it restores the context of the newly-chosen process. See the "Context Switch" slides for much more information about the operation of <a class="el" href="kernel_8h.html#aaae42c37d7e61697646625aafaeae957" title="Implements a context switch in TOS, giving another process a chance to run. ">resign()</a>. Also note that the implementation of <a class="el" href="kernel_8h.html#aaae42c37d7e61697646625aafaeae957" title="Implements a context switch in TOS, giving another process a chance to run. ">resign()</a> changes somewhat when interrupts are introduced later in the course. See the "Preemptive Multitasking" slide deck for more information at the appropriate time in the course. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a3b26baa874c4de9d0db0020a495f307e" title="Selects and returns the next process to run. ">dispatcher()</a>, <a class="el" href="kernel_8h.html#a087ab3f9b5dff3f23f91a1b6e66e5072" title="The actively-running process. ">active_proc</a>, <a class="el" href="kernel_8h.html#aaae42c37d7e61697646625aafaeae957" title="Implements a context switch in TOS, giving another process a chance to run. ">resign()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a70e779a204bd7960376d8f122d5afd5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void send </td>
          <td>(</td>
          <td class="paramtype">PORT&#160;</td>
          <td class="paramname"><em>dest_port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a message to the <a class="el" href="struct__PORT__DEF.html">PORT</a> of a receiver process, and a reply to the message is expected. </p>
<p>This function sends a synchronous message to the destination <a class="el" href="struct__PORT__DEF.html">PORT</a> indicated by the parameter dest_port. The void pointer data is the content of the message. If the receiver process has not yet called <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a>, the sender becomes <a class="el" href="kernel_8h.html#ac2a702a7f1c65e77a83166f4642ae6e7" title="This state is assigned to a process that has called send(), but the receiver process has not yet call...">STATE_SEND_BLOCKED</a> and is placed on the send-blocked list until the receiver calls <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a>, at which time the sender becomes <a class="el" href="kernel_8h.html#a600b8498ae32f931e812309e3ea0b715" title="This state is assigned to a sending process in the situation where the process has called send() and ...">STATE_REPLY_BLOCKED</a>. If the receiver process had already called <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a>, then the message is delivered immediately to the receiver and the sender process becomes <a class="el" href="kernel_8h.html#a600b8498ae32f931e812309e3ea0b715" title="This state is assigned to a sending process in the situation where the process has called send() and ...">STATE_REPLY_BLOCKED</a> and awaits the receiver's reply. Once the receiver process calls <a class="el" href="kernel_8h.html#afae559b6ee61d6e596c651dde6028582" title="Replies to a message. ">reply()</a>, the sender process becomes <a class="el" href="kernel_8h.html#aa74af0876332d1a6258cff9745a1bd53" title="This state is assigned to processes that are eligible to run and are ready to use CPU cycles...">STATE_READY</a> and can go back on the ready queue. See the slides on inter-process communication for more details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dest_port</td><td>A <a class="el" href="struct__PORT__DEF.html">PORT</a> owned by the receiver process, which must be open if the message is to be deliverable. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>A void pointer to the data contained in the message. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct__PORT__DEF.html">PORT</a>, <a class="el" href="kernel_8h.html#aacc4f7df1c840c0e6f109dfde5ff934f" title="Sends a message to the PORT of a receiver process, from which no reply is expected. ">message()</a>, <a class="el" href="kernel_8h.html#a57fe8a985abbaec28b7065d0ad3b3e80" title="Receives a message. ">receive()</a>, <a class="el" href="kernel_8h.html#afae559b6ee61d6e596c651dde6028582" title="Replies to a message. ">reply()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0d4958487f6319a4e9deed6ae1962be3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void set_train_speed </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>speed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the speed of the model train. </p>
<p>This function will be implemented as a part of the final project. </p>

</div>
</div>
<a class="anchor" id="a74f2037d58ac553379390c7966e09bf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void show_cursor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structWINDOW.html">WINDOW</a> *&#160;</td>
          <td class="paramname"><em>wnd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays the cursor at the current cursor location. </p>
<p>Shows the cursor of the window by displaying cursor_char at the current cursor location, specified by (cursor_x, cursor_y). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wnd</td><td>Pointer to the <a class="el" href="structWINDOW.html" title="Contains the properties of a specific window. ">WINDOW</a> struct that specifies the window. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#ab406d8dcb6b139a7d87d4feae5e66895" title="Removes the cursor from a window. ">remove_cursor()</a>, <a class="el" href="structWINDOW.html" title="Contains the properties of a specific window. ">WINDOW</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2d8ece954c7a70eb04493321c6e46f3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sleep </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_of_ticks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts the calling process to sleep (off the ready queue) for a specified number of timer ticks. </p>
<p>This function is a wrapper that client processes use to create and send a <a class="el" href="struct__Timer__Message.html">Timer_Message</a> to the timer process, indicating that the client process wishes to sleep for the number of timer ticks indicated by the argument num_of_ticks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_of_ticks</td><td>Integer specifying the number of timer ticks that the calling process wants to sleep. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct__Timer__Message.html">Timer_Message</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af85f715505e3c0142953633dc5f7b763"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void start_pong </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a new game of pong. </p>
<p>In the shell application to be implemented as part of the final project, one of the available shell commands will be to start a new game of pong. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a22a370c075a0550a77d5954725f01f96" title="Starts a new TOS shell window. ">start_shell()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a22a370c075a0550a77d5954725f01f96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void start_shell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Starts a new TOS shell window. </p>
<p>This function will be implemented as a part of the final project. </p>

</div>
</div>
<a class="anchor" id="a88ae83b120b2747f3791ef7bc743de62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vsprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>argp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implements formatted-print features of the <a class="el" href="kernel_8h.html#ae02cb6e6121bb801f5a6411769adc6ee" title="Prints content to a window in accordance with the specified format or conversion. ...">wprintf()</a> and <a class="el" href="kernel_8h.html#a199a1f701f4cc4fd1c3ff7903a102d7a" title="Prints content to the kernel_window in accordance with the specified format or conversion. ">kprintf()</a> functions. </p>
<p>Parses the format specifiers and conversions provided as parameters to <a class="el" href="kernel_8h.html#ae02cb6e6121bb801f5a6411769adc6ee" title="Prints content to a window in accordance with the specified format or conversion. ...">wprintf()</a> and <a class="el" href="kernel_8h.html#a199a1f701f4cc4fd1c3ff7903a102d7a" title="Prints content to the kernel_window in accordance with the specified format or conversion. ">kprintf()</a> calls and populates a character buffer with an output string, correctly formatted in accordance with the behavior of the C function printf(). The functions <a class="el" href="kernel_8h.html#ae02cb6e6121bb801f5a6411769adc6ee" title="Prints content to a window in accordance with the specified format or conversion. ...">wprintf()</a> and <a class="el" href="kernel_8h.html#a199a1f701f4cc4fd1c3ff7903a102d7a" title="Prints content to the kernel_window in accordance with the specified format or conversion. ">kprintf()</a> then print the correctly-formatted content to a window. The full list of supported format specifiers and the number of arguments expected for each specifier is documented in <a class="el" href="kernel_8h.html#ae02cb6e6121bb801f5a6411769adc6ee" title="Prints content to a window in accordance with the specified format or conversion. ...">wprintf()</a> and <a class="el" href="kernel_8h.html#a199a1f701f4cc4fd1c3ff7903a102d7a" title="Prints content to the kernel_window in accordance with the specified format or conversion. ">kprintf()</a>. Like printf(), this function can take variable argument lists: the data type va_list supports such lists and enables this function to act accordingly to each format specifier. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Pointer to the first character in a buffer containing the data to be printed. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>Pointer to a first character in a constant character buffer containing the format specifier. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argp</td><td>A va_list, which is a type that holds information about variable arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#ae02cb6e6121bb801f5a6411769adc6ee" title="Prints content to a window in accordance with the specified format or conversion. ...">wprintf()</a>, <a class="el" href="kernel_8h.html#a199a1f701f4cc4fd1c3ff7903a102d7a" title="Prints content to the kernel_window in accordance with the specified format or conversion. ">kprintf()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7c66a2884e17fb661a5a485dcca9e26f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wait_for_interrupt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>intr_no</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Causes a process to wait until the specified interrupt occurs. </p>
<p>The process calling this function will become <a class="el" href="kernel_8h.html#a81b88515a00640cd5475dc031dc4424b" title="This state is assigned to a process that is waiting for an interrupt to occur. ">STATE_INTR_BLOCKED</a> until the interrupt identified by intr_no occurs. When that interrupt occurs, the process is added back to the ready queue. A process can wait for only one interrupt at a time, and only one process can be waiting for a particular interrupt. The only valid values for intr_no are <a class="el" href="kernel_8h.html#a7095fb363d08f6646611f9a47806647b" title="The number associated with a timer interrupt. ">TIMER_IRQ</a>, <a class="el" href="kernel_8h.html#ab1cd1e736761fd2efc00615782a271e6" title="The number associated with a keyboard interrupt. ">KEYB_IRQ</a> and <a class="el" href="kernel_8h.html#a3685c78b9bd6dd0fa3861807e24a4e1b" title="The number associated with a COM1 interrupt. ">COM1_IRQ</a>, corresponding to the timer, keyboard, and COM1 interrupts respectively. Each of these values is indicated by a #define preprocessor directive in <a class="el" href="kernel_8h.html" title="Header file for the TOS kernel. ">kernel.h</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a7095fb363d08f6646611f9a47806647b" title="The number associated with a timer interrupt. ">TIMER_IRQ</a>, <a class="el" href="kernel_8h.html#ab1cd1e736761fd2efc00615782a271e6" title="The number associated with a keyboard interrupt. ">KEYB_IRQ</a>, <a class="el" href="kernel_8h.html#a3685c78b9bd6dd0fa3861807e24a4e1b" title="The number associated with a COM1 interrupt. ">COM1_IRQ</a>, <a class="el" href="kernel_8h.html#a88ada49c1954d38252049786595d9a5f" title="Initializes the interrupt subsystem of TOS. ">init_interrupts()</a>, <a class="el" href="kernel_8h.html#add2a7dc4c8b814a7e11ffc87780df7d7" title="Initializes the IDT entry for a single interrupt. ">init_idt_entry()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a960a429457157abb6b3ecbbec4c8a243"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wm_clear </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>window_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the window and places the cursor in the top left corner of the window. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">window_id</td><td>The integer identifier of the window to be cleared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#ad7c52bde65decfbe97201240835205c0" title="Primts a formatted string to the window. ">wm_print</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8ee6330fe2c39feda7b1a2e909452db5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int wm_create </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new window via the Window Manager service. </p>
<p>Unlike the window implementation from early on in the course, this function can create a window that overlaps with other windows. The Z-order of the windows is discussed in more detail near the end of the course. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The x-axis coordinate of the upper left corner of the window. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The y-axis coordinate of the upper left corner of the window. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">width</td><td>The width of the window. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">height</td><td>The height of the window. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer identifier of the created window. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#ad7c52bde65decfbe97201240835205c0" title="Primts a formatted string to the window. ">wm_print</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ad7c52bde65decfbe97201240835205c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wm_print </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>window_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Primts a formatted string to the window. </p>
<p>This function accepts strings formatted in the same way as the C printf() function. Consult the documentation on <a class="el" href="kernel_8h.html#ae02cb6e6121bb801f5a6411769adc6ee" title="Prints content to a window in accordance with the specified format or conversion. ...">wprintf()</a> for more details about the available formats. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">window_id</td><td>The identifier of the window. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>Pointer to the string to be printed and which may include format tags. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Refers to zero or more optional arguments that specify the format(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#ae02cb6e6121bb801f5a6411769adc6ee" title="Prints content to a window in accordance with the specified format or conversion. ...">wprintf</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a107a138b4d263da9906636004b9cdf28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wm_set_cursor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>window_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the cursor to a given position in the window. </p>
<p>This function also allows the cursor character to be changed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">window_id</td><td>The identifier of the window. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>The x-axis coordinate of the new cursor location. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>The y-axis coordinate of the new cursor location. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>The new cursor character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a960a429457157abb6b3ecbbec4c8a243" title="Clears the window and places the cursor in the top left corner of the window. ">wm_clear</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae02cb6e6121bb801f5a6411769adc6ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wprintf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structWINDOW.html">WINDOW</a> *&#160;</td>
          <td class="paramname"><em>wnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints content to a window in accordance with the specified format or conversion. </p>
<p><a class="el" href="kernel_8h.html#a199a1f701f4cc4fd1c3ff7903a102d7a" title="Prints content to the kernel_window in accordance with the specified format or conversion. ">kprintf()</a> and <a class="el" href="kernel_8h.html#ae02cb6e6121bb801f5a6411769adc6ee" title="Prints content to a window in accordance with the specified format or conversion. ...">wprintf()</a> are the TOS version of the C function printf(), allowing formatted printing or conversion and variable argument lists. Example usages of <a class="el" href="kernel_8h.html#ae02cb6e6121bb801f5a6411769adc6ee" title="Prints content to a window in accordance with the specified format or conversion. ...">wprintf()</a> can be found in the lectures slides. This function is the same as <a class="el" href="kernel_8h.html#a199a1f701f4cc4fd1c3ff7903a102d7a" title="Prints content to the kernel_window in accordance with the specified format or conversion. ">kprintf()</a>, except that <a class="el" href="kernel_8h.html#a199a1f701f4cc4fd1c3ff7903a102d7a" title="Prints content to the kernel_window in accordance with the specified format or conversion. ">kprintf()</a> prints to the <a class="el" href="kernel_8h.html#aeb93d089146101ad08f141c0fc2c6b15" title="Pointer to a WINDOW struct for a window that covers the entire screen. ">kernel_window</a>. Supported printf features and conversions include d (decimal), u (unsigned), x (hexadecimal), X (hex with capital letters), o (octal), c (character), s (string), %m.n (field width and precision), %%-m.n (left adjustment), %0m.n (zero-padding), %%*.* (width and precision taken from arguments), and b (binary conversion). The function <a class="el" href="kernel_8h.html#a88ae83b120b2747f3791ef7bc743de62" title="Implements formatted-print features of the wprintf() and kprintf() functions. ">vsprintf()</a> parses the format specifier and optional arguments and creates a character buffer containing the output string correctly formatted in accordance with how printf() behaves. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wnd</td><td>Pointer to the <a class="el" href="structWINDOW.html" title="Contains the properties of a specific window. ">WINDOW</a> struct that specifies the window. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>Pointer to the string to be printed and which may include format tags. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">...</td><td>Refers to zero or more optional arguments that specify the format(s). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a199a1f701f4cc4fd1c3ff7903a102d7a" title="Prints content to the kernel_window in accordance with the specified format or conversion. ">kprintf()</a>, <a class="el" href="kernel_8h.html#a88ae83b120b2747f3791ef7bc743de62" title="Implements formatted-print features of the wprintf() and kprintf() functions. ">vsprintf()</a>, <a class="el" href="kernel_8h.html#ae430920aa5940d9c9e34a5ec6e5c1ed8" title="Displays a string starting at the cursor location, and advances the cursor appropriately after the en...">output_string()</a>, <a class="el" href="structWINDOW.html" title="Contains the properties of a specific window. ">WINDOW</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a087ab3f9b5dff3f23f91a1b6e66e5072"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kernel_8h.html#a831d87f38811800ce0698bbe85e6b386">PROCESS</a> active_proc</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The actively-running process. </p>
<p>active_proc is a pointer to the PCB entry for the currently-running process, meaning that this process is <a class="el" href="kernel_8h.html#aa74af0876332d1a6258cff9745a1bd53" title="This state is assigned to processes that are eligible to run and are ready to use CPU cycles...">STATE_READY</a> and is currently using the CPU. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="struct__PCB.html">PCB</a>, <a class="el" href="kernel_8h.html#a5e64f2ad93cc9de92000f884e6e0a8a9" title="An array of twenty PCB structs. ">pcb</a>, <a class="el" href="kernel_8h.html#a831d87f38811800ce0698bbe85e6b386" title="Typedef for a pointer to a PCB struct. ">PROCESS</a>, <a class="el" href="kernel_8h.html#aaae42c37d7e61697646625aafaeae957" title="Implements a context switch in TOS, giving another process a chance to run. ">resign()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3235fc563e60489c99c3a3959ead5f24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PORT com_port</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="struct__PORT__DEF.html">PORT</a> owned by the COM process to receive messages from user processes. </p>
<p>This global variable refers to the <a class="el" href="struct__PORT__DEF.html">PORT</a> which is owned by the COM process and receives messages (of type <a class="el" href="struct__COM__Message.html">COM_Message</a>) from user processes that wish to send and/or receive bytes from the COM1 I/O port. This global is initialized in <a class="el" href="kernel_8h.html#a667529bb896d3107cb5d62f608dceaa5" title="Initializes the COM subsystem of TOS. ">init_com()</a>. Note that the COM process owns a second port, at which messages from the COM Reader process are received. See the "Device Drivers" lecture slides for more information about the COM Process and COM Reader Process. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a667529bb896d3107cb5d62f608dceaa5" title="Initializes the COM subsystem of TOS. ">init_com()</a>, <a class="el" href="struct__COM__Message.html">COM_Message</a>, <a class="el" href="struct__PORT__DEF.html">PORT</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a380792ed8611865e8009047a3fee62b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="kernel_8h.html#a050c65e107f0c828f856a231f4b4e788">BOOL</a> interrupts_initialized</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A global variable indicating whether interrupts are enabled (TRUE) or disabled (FALSE). </p>
<p>Some of the older TOS test cases will stop working once support for interrupts is implemented, because of changes made to the implementations of <a class="el" href="kernel_8h.html#ae982573084c63244f2b0c4f8acb043f7" title="Creates a new TOS process and returns the PORT owned by the new process (or, before ports are covered...">create_process()</a> and <a class="el" href="kernel_8h.html#aaae42c37d7e61697646625aafaeae957" title="Implements a context switch in TOS, giving another process a chance to run. ">resign()</a> during the pre-emptive multitasking part of the course. The interrupts_initialized variable is consulted to ensure that <a class="el" href="kernel_8h.html#ae982573084c63244f2b0c4f8acb043f7" title="Creates a new TOS process and returns the PORT owned by the new process (or, before ports are covered...">create_process()</a> and <a class="el" href="kernel_8h.html#aaae42c37d7e61697646625aafaeae957" title="Implements a context switch in TOS, giving another process a chance to run. ">resign()</a> will function correctly whether interrupts are enabled or disabled. The variable is initially set to FALSE. As the assembly instructions associated with <a class="el" href="kernel_8h.html#a532d7d98780162a882090e6c0e1e36fe" title="Assembly instructions that disable the interrupt subsystem of TOS to avoid race conditions. ">DISABLE_INTR</a> and <a class="el" href="kernel_8h.html#a529e0c1767f0b71a5269eeb7b09528cf" title="Assembly instructions that enable the interrupt subsystem of TOS. ">ENABLE_INTR</a> are executed, this variable is updated accordingly. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a050c65e107f0c828f856a231f4b4e788" title="Typedef for true/false values, as an integer. ">BOOL</a>, <a class="el" href="kernel_8h.html#a88ada49c1954d38252049786595d9a5f" title="Initializes the interrupt subsystem of TOS. ">init_interrupts()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aeb93d089146101ad08f141c0fc2c6b15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structWINDOW.html">WINDOW</a>* kernel_window</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointer to a <a class="el" href="structWINDOW.html" title="Contains the properties of a specific window. ">WINDOW</a> struct for a window that covers the entire screen. </p>
<p>The kernel_window is a pointer to a <a class="el" href="structWINDOW.html" title="Contains the properties of a specific window. ">WINDOW</a> struct whose members have the following values: x=0, y=0, width=80, height=25, cursor_x=0, cursor_y=0, cursor_char=' '. In the assignment WINDOW* kernel_window = &amp;kernel_window_def shown above, kernel_window_def is a <a class="el" href="structWINDOW.html" title="Contains the properties of a specific window. ">WINDOW</a> with the above values. As a result, this variable kernel_window is initialized with a pointer to that <a class="el" href="structWINDOW.html" title="Contains the properties of a specific window. ">WINDOW</a>. </p>

</div>
</div>
<a class="anchor" id="afc32d8217e2da0da36dc851cbc97cdac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PORT keyb_port</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="struct__PORT__DEF.html">PORT</a> owned by the keyboard process. </p>
<p>Processes that need to get a keystroke from the keyboard process send messages to this port. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a48cd3acd7319667c875c62b570b9db49" title="Initializes the keyboard process. ">init_keyb()</a>, <a class="el" href="struct__Keyb__Message.html">Keyb_Message</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5e64f2ad93cc9de92000f884e6e0a8a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCB pcb[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An array of twenty <a class="el" href="struct__PCB.html">PCB</a> structs. </p>
<p>Each element in this array is a pointer to the PCB data structure for one TOS process. TOS processes are never removed from this array: when a process has completed its task, its state becomes <a class="el" href="kernel_8h.html#a8e13ad68fa4d5752084a5ef0e0085a66" title="This state is assigned to processes that are permanently off the ready_queue and will never run again...">STATE_ZOMBIE</a> and it remains in this array. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#ae982573084c63244f2b0c4f8acb043f7" title="Creates a new TOS process and returns the PORT owned by the new process (or, before ports are covered...">create_process()</a>, <a class="el" href="struct__PCB.html">PCB</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab4e099987c910c0a74ddb26ffe7b1774"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PCB* ready_queue[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An array of pointers to PCBs for those processes that are ready to use CPU cycles. </p>
<p>The ready-queue contains pointers to the PCBs of those processes that are <a class="el" href="kernel_8h.html#aa74af0876332d1a6258cff9745a1bd53" title="This state is assigned to processes that are eligible to run and are ready to use CPU cycles...">STATE_READY</a>, meaning that they are eligible for CPU cycles. A process in any other state is not eligible to use the CPU, either because it has become a "zombie" process or it is in one of the blocked states. Only one process can use the CPU at any given time, so the ready_queue is consulted by the dispatcher to determine which process should be the next to run. TOS uses priority-based round robin scheduling. The ready queue is an 8-element array, with each element corresponding to one of the priority levels, 0-7. Higher-priority processes are chosen to run before lower-priority processes. Within the same priority level, a round-robin scheduling approach is used; to implement this approach, each PCB in the ready_queue maintains a doubly-linked list of processes, so that within a priority level, the dispatcher will return the next process in this priority level (or, if there is only one process at this priority level, the same process will be returned). See the lecture slide called "Scheduling" for more information. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="kernel_8h.html#a3b26baa874c4de9d0db0020a495f307e" title="Selects and returns the next process to run. ">dispatcher()</a>, <a class="el" href="struct__PCB.html">PCB</a>, <a class="el" href="kernel_8h.html#ab4e099987c910c0a74ddb26ffe7b1774" title="An array of pointers to PCBs for those processes that are ready to use CPU cycles. ">ready_queue</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7271a38be80889290a3b624f3d6bad83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PORT timer_port</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The <a class="el" href="struct__PORT__DEF.html">PORT</a> owned by the timer process. </p>
<p>To use the timer service, a client process sends a Timer_Message to this port indicating the number of timer ticks for which the client process wants to wait. The timer notifier process also messages this port whenever a timer interrupt occurs. See the "Timer" lecture slides for more information. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="struct__Timer__Message.html">Timer_Message</a>, <a class="el" href="kernel_8h.html#a2d8ece954c7a70eb04493321c6e46f3c" title="Puts the calling process to sleep (off the ready queue) for a specified number of timer ticks...">sleep()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<!--
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
-->
</body>
</html>
